<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态网页数据抓取]]></title>
    <url>%2F190703%2F</url>
    <content type="text"><![CDATA[动态页面数据抓取什么是AJAXAJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。在后台与服务器进行少量数据换时，可以在不重新加载整个网页的情况下，利用Ajax对网页实现异步更新。在传统的网页中，如果要获取更新内容，需要重新加载整个页面。因为传统的网页数据传输格式使用的是XML语法。在Ajax加载的网页中，数据的交互使用的是JSON格式。 获取ajax数据的格式 直接分析ajax调用的接口，然后通过代码请求接口。 使用selenium+chromedriver模拟浏览器的行为获取数据。 方式 优点 缺点 分析接口 直接可以请求到数据，不需要做一些解析工具，代码量少，性能高。 分析接口比较复杂，特别是一些通过js混淆的接口，需要有js的功底。容易被发现是爬虫。 selenium 直接模拟浏览器的行为，浏览器能请求到的，使用selenium也同样可以获取。爬虫更稳定。 代码量多，性能低。 selenium + chromdriver获取动态数据Selenium是一个自动化测试工具，可以在模拟人类在浏览器上的行为，自动处理浏览器上的一些行为，如点击，填充数据，删除cookie等。chromedriver是一个chrome浏览器的驱动程序。 Chromedriver：http://npm.taobao.org/mirrors/chromedriver 安装Selenium和chromedriver 安装selenium：pip install selenium 安装chromedriver：下载完毕后，放到自己能找到的英文目录中即可。 快速开始以一个例子快速开始 123456789101112from selenium import webdriverimport timedriver_path = './driver/chromedriver.exe'url = "https://www.baidu.com"driver = webdriver.Chrome(executable_path=driver_path)driver.get(url)print(driver.page_source)time.sleep(5)driver.close() 在运行之后会出现一个浏览器框，并自动的访问百度 selenium官方文档https://selenium-python.readthedocs.io/index.html 关闭页面 driver.close()：关闭当前页面 driver.quit()：退出整个浏览器 定位元素 find_element_by_id：根据id查找某个元素 123submitTag = driver.find_element_by_id('su')### 等价于submitTag = driver.find_element(By.ID, 'su') find_element_by_class_name：根据类名查找元素 123submitTag = driver.find_element_by_class_name('s_ipt')### 等价于submitTag = driver.find_element(By.CLASS, 's_ipt') find_element_by_name：根据name属性的值来查找元素 123submitTag = driver.find_element_by_name('email')### 等价于submitTag = driver.find_element(By.NAME,'email') find_element_by_tag_name：根据标签名来查找元素 123submitTag = driver.find_element_by_tag_name('div')### 等价于submitTag = driver.find_element(By.TAG_NAME,'div') find_element_by_xpath：根据xpath语法来获取元素 123submitTag = driver.find_element_by_xpath('//div')### 等价于submitTag = driver.find_element(By.XPATH,'//div') find_element_by_css_selector：根据css选择器选择元素 123submitTag = driver.find_element_by_css_selector('//div')### 等价于submitTag = driver.find_element(By.CSS_SELECTOR,'//div') By模块导入 1from selenium.webdriver.common.by import By 注意：find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素 操作表单元素 在操作输入框时需要分为两步，一：找到表单元素，二：填充数据。 12inputTag = driver.find_element_by_id('kw')inputTag.send_keys("Python") 使用clear方法可以清除输入框中的内容 inputTag.clear() 操作checkbox时，需要先选中checkbox标签，然后执行click事件。 12rememberTag = driver.find_element_by_name("rememberMe")rememberTag.click() 选择select时，不能直接点击，因为点击后还需要选中元素。因此在selenium中专门为select标签设置了一个类selenium.webdriver.support.ui.Select。将获取到的元素当成参数传到这个类中，创建这个对象，之后就可以使用这个对象进行选择了。 123456789101112131415from selenium.webdriver.support.ui import Select### 选中标签创建对象selectTag = Select(driver.find_element_by_name("jumpMenu"))### 根据索引选择selectTag.select_by_index(1)### 根据值选择selectTag.select_by_value("https://www.python.org")### 根据可视化文本选择selectTag.select_by_visible_text("Python")### 取消选中的所有选项selectTag.deselect_all() 操作按钮： 12inputTag = driver.find_element_by_id("su")inputTag.click() 行为链有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类ActionChains来完成。如将鼠标移到某个元素并执行点击事件。 123456789inputTag = driver.find_element(By.ID, 'kw')submitTag = driver.find_element_by_id('su')actions = webdriver.ActionChains(driver)actions.move_to_element(inputTag)actions.send_keys_to_element(inputTag, 'Python')actions.move_to_element(submitTag)actions.click(submitTag)actions.perform() 更多鼠标相关操作 click_and_hold(element)：点击但不松开鼠标 context_click(element)：右键点击 double_click(element)：双击 更多方法：https://selenium-python.readthedocs.io/api.html Cookie操作 获取所有的cookie 12for cookie in driver.get_cookies(): print(cookie) 根据cookie的key获取value 1value = driver.get_cookie(key) 删除所有的cookie 1driver.delete_all_cookies() 删除某个cookie 1driver.delete_cookie(key) 页面等待现在的网页多采用 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，在使用了WebElement时，就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。 隐式等待 调用driver.implicitly_wait。 1234driver = webdriver.Chrome(executable_path=driver_path)driver.implicitly_wait(10)# 请求网页driver.get("https://www.douban.com/") 显式等待 显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用selenium.webdriver.support.excepted_conditions期望的条件和selenium.webdriver.support.ui.WebDriverWait来配合完成。 12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firefox()driver.get("http://somedomain/url_that_delays_loading")try: element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, "myDynamicElement")) )finally: driver.quit() 其他的等待条件 presence_of_element_located：某个元素已经加载完毕了。 presence_of_all_emement_located：网页中所有满足条件的元素都加载完毕了。 element_to_be_cliable：某个元素是可以点击了。 更多条件请参考：http://selenium-python.readthedocs.io/waits.html 切换页面在切换页面时，selenium提供了一个叫做switch_to_window来进行切换，具体切换到哪个页面，可以从driver.window_handles中找到。 1234# 打开一个新的页面self.driver.execute_script("window.open('"+url+"')")# 切换到这个新的页面中self.driver.switch_to_window(self.driver.window_handles[1]) 设置代理1234567891011from selenium import webdriverimport timeoptions = webdriver.ChromeOptions()options.add_argument("--proxy-server=http://175.44.156.200:9000")driver_path = "./driver/chromedriver.exe"driver = webdriver.Chrome(executable_path=driver_path, options=options)driver.get('http://httpbin.org/ip')time.sleep(5)driver.quit() WebElement元素from selenium.webdriver.remote.webelement import WebElement类是每个获取出来的元素的所属类 常用属性： get_attribute：这个标签的某个属性的值。 screentshot：获取当前页面的截图。这个方法只能在driver上使用。driver的对象类，也是继承自WebElement。 对带有页面嵌套的豆瓣进行登录12345678910111213141516171819202122232425262728293031from selenium import webdriverimport timedriver_path = "./driver/chromedriver.exe"driver = webdriver.Chrome(executable_path=driver_path)driver.get('https://www.douban.com')iframe = driver.find_element_by_tag_name("iframe")driver.switch_to.frame(iframe)login = driver.find_element_by_class_name("account-tab-account")actions = webdriver.ActionChains(driver)actions.move_to_element(login)actions.click()actions.perform()username = driver.find_element_by_id("username")password = driver.find_element_by_id("password")submit = driver.find_element_by_xpath("//div[@class='account-form-field-submit ']/a")actions.move_to_element(username)actions.send_keys_to_element(username, "your username")actions.move_to_element(password)actions.send_keys_to_element(password, "your password")actions.move_to_element(submit)actions.click()actions.perform()time.sleep(10)driver.quit() 注意：在使用以下内容时会出现警告信息，身为有代码洁癖的人，最不能忍受运行中出现警告信息。 警告信息： 1DeprecationWarning: use driver.switch_to.frame instead driver.switch_to_frame(iframe) 使用方式： 12iframe = driver.find_element_by_tag_name("iframe")driver.switch_to_frame(iframe) 将上文改为即可： 12iframe = driver.find_element_by_tag_name("iframe")driver.switch_to.frame(iframe) 对框架的解决方式推荐一篇文章：Selenium（十二）嵌套frame定位]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>Selenium</tag>
        <tag>chromedriver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程爬虫]]></title>
    <url>%2F190630%2F</url>
    <content type="text"><![CDATA[多线程介绍多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就好比多线程是火车的每一节车厢，而进程就是火车，车厢离开火车无法启动。多线程的出现是为了提高效率。 threading模块介绍threading模块是python中专门提供用来多线程编程的模块。threading模块中最常用的类是Thread。 12345678910111213141516171819202122import threadingimport timedef coding(): for x in range(3): print(f"&#123;x&#125; 正在写代码") time.sleep(1)def drawing(): for x in range(3): print(f"&#123;x&#125; 正在画图") time.sleep(1)def multi_thread(): t1 = threading.Thread(target=coding) t2 = threading.Thread(target=drawing) t1.start() t2.start() if __name__ == "__main__": multi_thread() 查看线程数使用threading.enumerate()函数可以看到当前线程的数量 查看当前线程的名字使用threading.current_thread()函数可以看到当前线程的信息。 继承自threading.Thread类为了让线程代码得到更好的封装，可以使用到threading模块下的Thread类，继承自Thread类后，然后实现run方法，线程代码会自动运行run方法中的代码。 123456789101112131415161718192021222324import threadingimport timeclass CodingThread(threading.Thread): def run(self): for x in range(5): print(f'&#123;threading.current_thread()&#125; 正在写代码') time.sleep(1)class DrawingThread(threading.Thread): def run(self): for x in range(3): print(f'&#123;threading.current_thread()&#125; 正在画图') time.sleep(1)def multi_thread(): t1 = CodingThread() t2 = DrawingThread() t1.start() t2.start() if __name__ == "__main__": multi_thread() 多线程共享全局变量的问题多线程都是在同一个进程中运行的，因此在进程中的全局变量多有线程都是可共享的。由于线程执行的顺序是无序的，线程如果同时执行，有可能会造成数据错误。例如： 1234567891011121314151617import threadingtickets = 0def get_ticket(): global tickets for x in range(1000000): tickets += 1 print(f"tickets: &#123;tickets&#125;")def main(): for x in range(2): t = threading.Thread(target=get_ticket) t.start()if __name__ == "__main__": main() 锁机制为了解决以上使用共享全局变量的问题，threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时无法使用，直到当前线程处理完成后，把锁释放，其他线程才能使用。 1234567891011121314151617181920import threadingtickets = 0lock = threading.Lock()def get_ticket(): global tickets lock.acquire() for x in range(1000000): tickets += 1 lock.release() print(f"tickets: &#123;tickets&#125;")def main(): for x in range(2): t = threading.Thread(target=get_ticket) t.start()if __name__ == "__main__": main() _注意_：lock锁加在修改全局变量的位置，如果只是访问全局变脸没有必要加锁。 Lock生产者和消费者模式生产者和消费者模式是多线程开发中经常看到的一种模式。生产者的线程专门用来生产一些数据，然后存放在一个中间变量中。消费者再从这个中间变量中取出数据进行消费。但是因为要使用中间变量，中间变量由于经常是些全局变量，因此在使用的时候需要使用Lock锁来保证数据完整性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import threadingimport randomimport timegMoney = 1000gLock = threading.Lock()# 记录生产者生产次数，在达到10次时停止生产gTimes = 0class Producer(threading.Thread): def run(self): global gMoney global gTimes while True: money = random.randint(100, 1000) gLock.acquire() if gTimes &gt;= 10: gLock.release() break gMoney += money print(f"&#123;threading.current_thread()&#125; 当前存入 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元") gTimes += 1 time.sleep(1) gLock.release()class Consumer(threading.Thread): def run(self): global gMoney global gTimes while True: money = random.randint(100, 500) gLock.acquire() if gMoney &gt; money: gMoney -= money print(f"&#123;threading.current_thread()&#125; 取出 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元") time.sleep(1) else: if gMoney &gt;= 10: gLock.release() break print(f"&#123;threading.current_thread()&#125; 想取出 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元，不足！") gLock.release()def main(): for x in range(5): Consumer(name=f"消费者线程&#123;x&#125;").start() for x in range(5): Producer(name=f"生产者线程&#123;x&#125;").start()if __name__ == "__main__": main() Condition生产者和消费者模式Lock中的生产者与消费者模式可以正常运行，但是存在一个问题，在消费者中，总是通过while死循环上锁的方式判断money的多少。由于上锁是一个很消耗CPU资源的行为，因此此方式不是最好的。还有一种更好的方式是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作，还可以提升程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行加锁，也可以在修改完毕后解锁。以下对部分常用函数进行简单介绍： acquire：上锁 release：解锁 wait：将当前线程处于等待状态，并且释放锁。可以被其他线程使用notify和notify_all函数进行唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。 notify：通知某个正在等待的线程，默认是第一个等待的线程。 notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import threadingimport randomimport timegMoney = 1000gCondition = threading.Condition()# 记录生产者生产次数，在达到10次时停止生产gTimes = 0gTotalTimes = 5class Producer(threading.Thread): def run(self): global gMoney global gCondition global gTimes while True: money = random.randint(100, 1000) gCondition.acquire() if gTimes &gt;= gTotalTimes: gCondition.release() print(f"当前生产者总共生产了&#123;gTimes&#125;次") break gMoney += money print(f"&#123;threading.current_thread()&#125; 当前存入 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元") gTimes += 1 time.sleep(1) gCondition.notify_all() gCondition.release()class Consumer(threading.Thread): def run(self): global gMoney global gCondition global gTimes while True: money = random.randint(100, 500) gCondition.acquire() while gMoney &lt; money: if gTimes &gt;= gTotalTimes: gCondition.release() return print(f"&#123;threading.current_thread()&#125; 想取出 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元，不足！") gCondition.wait() gMoney -= money print(f"&#123;threading.current_thread()&#125; 取出 &#123;money&#125; 元，剩余 &#123;gMoney&#125; 元") time.sleep(1) gCondition.release()def main(): for x in range(5): Consumer(name=f"消费者线程&#123;x&#125;").start() for x in range(5): Producer(name=f"生产者线程&#123;x&#125;").start()if __name__ == "__main__": main() Queue线程安全队列在线程中，访问一些全局变量，加锁是一个经常的过程。如果你想把一些数据存储到某个队列中，可以使用Python内置的Queue模块。Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列、LIFO(后进先出)队列。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列实现线程间的同步。相关函数： 初始化Queue(maxsize)：创建一个先进先出的队列 qsize()：返回队列的大小 empty()：判断队列是否为空 full()：判断队列是否满了 get()：从队列中取最后一个数据 put()：将一个数据放到队列中 使用生产者消费者模式多线程下载表情包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485## demo.pyimport threadingimport requestsimport osimport refrom lxml import etreeimport utilfrom queue import Queueclass Producer(threading.Thread): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', &#125; def __init__(self, page_queue, img_queue, *args, **kwargs): super(Producer, self).__init__(*args, **kwargs) self.page_queue = page_queue self.img_queue = img_queue def run(self): while True: if self.page_queue.empty(): break url = self.page_queue.get() self.parse_page(url) def parse_page(self, url): response = requests.get(url, headers=self.headers) text = response.text html = etree.HTML(text) imgs = html.xpath('//a[@class="col-xs-6 col-sm-3"]/img') for img in imgs: if img.get('class') == 'gif': continue img_url = img.get('data-original') suffix = os.path.splitext(img_url)[1].replace('.null', '.jpg') alt = img.get('alt') alt = re.sub(r'[，。？！!?,/\\.]', '', alt) img_name = alt + suffix self.img_queue.put((img_url, img_name))class Consumer(threading.Thread): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', &#125; def __init__(self, page_queue, img_queue, *args, **kwargs): super(Consumer, self).__init__(*args, **kwargs) self.page_queue = page_queue self.img_queue = img_queue def run(self): while True: if self.img_queue.empty(): if self.page_queue.empty(): return img = self.img_queue.get(block=True) url, filename = img if not os.path.exists('images'): os.makedirs('images/') result = util.retrieve(url, headers=self.headers, path='images/'+filename) if result: print(f'&#123;filename&#125; 下载完成!') else: print(f'&#123;filename&#125; 下载失败！')def main(): page_queue = Queue(100) img_queue = Queue(500) for x in range(1, 10): url = f'http://www.doutula.com/photo/list/?page=&#123;x&#125;' page_queue.put(url) for x in range(5): t = Producer(page_queue, img_queue) t.start() for x in range(5): t = Consumer(page_queue, img_queue) t.start()if __name__ == '__main__': main() 123456789101112131415161718192021# util.pyfrom urllib import parse, requestdef retrieve(url, headers=None, path=None): if not isinstance(headers, dict): return False opener = request.build_opener() opener.addheaders = [result for result in zip(headers.keys(), headers.values())] request.install_opener(opener) request.urlretrieve(url, path) return Truedef urlopen(url, headers=None, data=None,origin_req_host=None, unverifiable=False, method=None): req = request.Request(url, headers=headers, data=data, origin_req_host=origin_req_host, unverifiable=unverifiable, method=method) resp = request.urlopen(req) return resp GIL全局解释器锁Python自带的解释器是CPython。CPython解释器的多线程实际上是一个伪多线程（在多核CPU中，只能利用一核，无法利用多核的优势）。同一时刻只有一个线程执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中便引入了GIL（Global Intepreter Lock），叫做全局解释器锁。因为在CPython解释器的内存管理不是线程安全的，所以还有其他的解释器。 Ipython Ipython是基于CPython之上一个交互解释器，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。 PyPy PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。在PyPy中，同样也是存在GIL锁的。 Jython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。不存在GIL锁。 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。不存在GIL锁。 GIL虽然是一个假的多线程，但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup4库]]></title>
    <url>%2F190628-1%2F</url>
    <content type="text"><![CDATA[和lxml一样，BeautifulSoup也是一个HTML/XML的解析器，主要的功能也是解析和提取HTML/XML数据。 lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有很大的开销，所以性能要低于lxml。 BeautifulSoup用来解析HTML比较简单，其API设计的非常人性化，同时BeautifulSoup也支持CSS选择器、Python标准库中的HTML解析器、lxml的XML。 安装：pip install bs4 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 对比： 解析工具 解析速度 使用难度 BeautifulSoup4 最慢 最简单 lxml 快 简单 正则 最快 最难 简单使用123456789101112131415161718from bs4 import BeautifulSouphtml = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""soup = BeautifulSoup(html, 'lxml')print(soup.prettify()) BeautifulSoup(markup, features):在使用的时候需要指定解析器，如果未指定，BeautifulSoup使用的Python标准库中的HTML解析器，同时beautifulsoup也支持第三方的解析器如lxml。另一个可供选择的解析器是纯Python实现的html5lib，html5lib的解析方式与浏览器相同。 安装lxml：pip install lxml 安装html5lib: pip install html5lib 主要解析器的优缺点： 四个常用的对象BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种： Tag NavigatableString BeautifulSoup Comment 操作讲解以下内容以4个例子的形式进行讲解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154# demo.pyfrom bs4 import BeautifulSouphtml = """&lt;div data-v-a6e3291a="" class="correlation-degree"&gt; &lt;div data-v-a6e3291a="" class="recruit-wrap recruit-margin"&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;TEG15-计费产品web前端开发工程师（深圳）&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯计费平台基础支付前端架构设计和开发工作； 参与需求评审、架构设计、编码设计和上线运维； 负责用户体验优化，包括但不限于：业务流程、前端展示、性能、安全等。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;PCG19-腾讯视频媒资后台开发工程师&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;北京,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;腾讯视频&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯视频媒资中台开发工作。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;TEG15-计费系统前端测试工程师（深圳）&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责web端/后台系统测试工作，从整个项目角度规划测试方法，达成项目质量目标； 负责web端/后台系统的自动化测试、性能测试，稳定性以及其它专项测试； 负责研究web端/后台系统测试技术，跟进业界测试技术发展，引进先进测试方法并开展二次开发，建立团队质量体系建设，有效提升测试效率&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;32032-资深后台开发工程师（上海）&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;IEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;上海,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;游戏服务器的功能开发和现有系统的持续优化； 负责服务器压力测试和性能优化； 负责服务器外网运营的持续跟进和优化。 &lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;WXG03-搜索自然语言算法工程师&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;广州,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责包括新词发现、命名实体识别、查询理解、意图提取、知识图谱、搜索喜好偏向性等相关系统的建设，用以优化微信小程序搜索各产品方向的流量分发，并参与工程实践。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;WXG03-搜索检索算法工程师&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;广州,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责微信小程序搜索各个产品方向的检索工作，内容包括页面识别、页面核心数据提取、页面分类、页面评分、词权重、排序等相关工作，并与开发工程师配合进行工程实践。 &lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;23486-证券业务C++后台开发高级工程师（深圳）&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责证券交易、风控、清算等系统的开发维护，建设证券业务相关的技术基础平台。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;22989-腾讯云数据平台产品中心运营开发&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;CSIG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯云数据平台产品的设计和研发。 负责云产品数据管理和服务的设计和研发。 负责构建和完善云底层数据的存储和查询，优化数据的质量和监控能力。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;18428-证券业务测试工程师&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;北京,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;财付通&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责证券类产品的功能、性能、安全、自动化等测试工作，包括终端/H5及后台系统的测试。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-v-a6e3291a="" class="recruit-list"&gt; &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt; &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;30360-后台平台开发（深圳）&lt;/h4&gt; &lt;p data-v-a6e3291a="" class="recruit-tips"&gt; &lt;span data-v-a6e3291a=""&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳总部,中国&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt; &lt;/p&gt; &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责QQ平台海量用户和数据的基础后台研发工作； 负责AI基础架构系统后台研发工作； 负责推荐系统，大数据分析计算后台研发工作。&lt;/p&gt; &lt;/a&gt; &lt;div data-v-a6e3291a="" class="recruit-collection"&gt; &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;"""soup = BeautifulSoup(html, 'lxml') 获取所有的class属性为“recruit-list”的div标签 123divs = soup.find_all('div', attrs=&#123;'class': "recruit-list"&#125;)for div in divs: print(div) 获取第二个class属性为“recruit-list”的div标签 12div = soup.find_all('div', attrs=&#123;'class': "recruit-list"&#125;, limit=2)[1]print(div) 获取所有的h4标签中的class属性 123h4_texts = soup.find_all('h4')for h4_text in h4_texts: print(h4_text['class']) 获取所有的职位信息（纯文本） 1aEs = soup.find_all('a') 方法一 输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容 123for aE in aEs: infos = list(aE.stripped_strings) print(infos) 方法二 1234567891011job = &#123;&#125;for aE in aEs: h4 = aE.find('h4').string ps = aE.find_all('p') spans = ps[0].find_all('span') span = '|'.join([s.string for s in spans]) p2 = ps[1].string job['title'] = h4 job['info'] = span job['desc'] = p2 print(job) 方法三 该方法提取出的内容中包含换行、空格。 12for aE in aEs: print(list(aE.strings)) _注意_： strings和stripped_strings、string属性和get_text方法： string：获取某个标签下的非标签字符串。返回值为字符串。 strings：获取某个标签下的所有非标签字符串，返回结果为一个生成器。 stripped_strings：获取某个标签下的所有非空行、非换行的非标签字符串，返回结果为一个生成器。 get_text：获取某个标签下的所有非标签字符串，返回结果为字符串。 搜索文档树find和find_all方法搜索文档树，一般采用较多的是这两个方法，一个是find，另一个是find_all方法。find方法是在文档树中找到第一个满足条件的标签后就返回结果。find_all方法是在文档树中找到所有满足条件的标签后返回结果。在这两个方法中最常用的用法是name和attr参数，其中也可以直接传入关键字，在传入关键字”class”时，需要将”class”变为”class_”。 1soup.find_all('div', class_="test") select方法在使用css选择器的方式时，需要使用select方法。以下为几种常用的css选择器方法： 通过标签名查找 1print(soup.select('a')) 通过类名查找 通过类名，应该在前面加一个”.”,比如要查找class=sister的标签。 1print(soup.select('.sister')) 通过id查找 通过id查找，应该在id的名字前面加一个”#”号。 1print(soup.select('#link1')) 通过组合查找 组合查找时，标签名和类名、id名进行组合的方式进行查找，例如查找p标签中，id等于link1的内容。 1print(soup.select("p #link1")) 直接子标签查找，则用”&gt;”分隔 1print(soup.select("head &gt; title")) 通过属性查找 查找时还可以加入属性元素，属性元素需要使用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配 1print(soup.select('a[href="http://example.com/elsie"]')) 获取内容 以上的select方法返回的结果都是以列表的形式返回的，可以进行遍历输出，然后使用get_text()方法获取其他的内容。 123456soup = BeautifulSoup(html, 'lxml')print(type(soup.select('title')))print(soup.select('title')[0].get_text())for title in soup.select('title'): print(title.get_text())]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>bs4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XPath语法详解]]></title>
    <url>%2F190628%2F</url>
    <content type="text"><![CDATA[Xpath语法和lxml模块什么是XPath？xpath (XML Path Language)是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。 XPath开发工具 Chrom插件XPath Helper FireFox插件XPath Checker XPath语法选取节点：Xpath使用路径表达式选取XML文档中的节点或 节点集。 表达式 描述 示例 结果 nodename 选取此节点的所有结点 bookstore 选取bookstore下所有的节点 / 如果是在最前面，代表从根节点选取。否者选取某节点下的某个节点 /bookstore 选取根元素下所有的bookstore节点 // 从全局节点中选择节点 //book 选取所有的bookstore节点 @ 选取某个节点的属性 //book[@id] 选取所有拥有id属性的book节点 谓语：谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。 路径表达式 描述 /bookstore/book[1] 选取bookstore下的第一个book元素 /bookstore/book[last()] 选取bookstore下的倒数第二个book元素 /bookstore/book[position() &lt; 3] 选取bookstore下前两个book元素 //book[@id] 选取拥有id属性的所有book元素 //book[@id=10] 选取所有id=10的所有book元素 通配符：* 表示通配符 通配符 描述 示例 结果 * 匹配任意节点 /bookstore/* 选取bookstore下所有的子元素 @* 匹配节点中的任何属性 //book[@*] 选取所有带有属性的book元素 选取多个路径：通过在路径表达式中使用“|”运算符，可以选取若干路径。 示例： 12//bookstore/book | //book/title### 选取所有book元素以及book元素下所有的title元素 运算符 运算符 描述 实例 返回值 &#124; 计算两个节点集 //book &#124; //cd 返回所有拥有book 和cd元素的节点集 + 加法 6+4 10 - 减法 6-4 2 * 乘法 6*4 24 div 除法 8 div 4 2 = 等于 id=101 如果id=101，则返回True，否则返回False != 不等于 id != 101 如果id != 101，则返回True，否则返回False &lt; 小于 id &lt; 101 如果id &gt; 101，则返回True，否则返回False &lt;= 小于或等于 id &lt;= 101 如果id &lt;= 101，则返回True，否则返回False > 大于 id &gt; 101 如果id > 101，则返回True，否则返回False >= 大于或等于 id &gt;= 101 如果id >= 101，则返回True，否则返回False or 或 id =100 or id = 101 如果id = 100 或id=101，返回True， 否则返回False and 与 id &gt; 100 and id &lt; 150 如果100 &lt; id &lt; 101,返回True，否则返回False mod 计算除法的余数 5 mod 2 1 注意: /和//的区别：/代表只获取直接子节点， //代表获取子孙节点。 contains：有时某个属性中包含多个值，可以使用模糊匹配的方式获取。 1//div[contaions(@class, &apos;job_detail&apos;)] lxml库lxml是一个HTML/XML的解析器，主要的功能是如何解析和提取HTML/XML数据。 lxml和正则一样，也是C实现的，是一款高性能的Python HTML/XML解析器，它可以用来快速的定位特定元素以及节点信息。 安装：pip install lxml 基本使用：在用lxml解析HTML代码的时候，如果HTML代码不规范，lxml库会自动的将其补全。 12345678910111213141516171819202122# 使用lxml的etree库from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link0.html"&gt;First item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;Second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link2.html"&gt;Third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link3.html"&gt;Fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;Fifth item&lt;/a&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)def print_result(html): result = etree.tostring(html, encoding='utf-8').decode('utf-8') print(result) print_result(html) 结果如下： 12345678910&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link0.html"&gt;First item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;Second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link2.html"&gt;Third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link3.html"&gt;Fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;Fifth item&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在解析html文件时，如果使用的lxml.etree.parse解析。该函数默认使用的解析器是XML解析器，所以，如果html文件中缺少相应标签，解析就会出错，此时可以自行创建解析器。 lxml的使用以上文的text为例： 获取ul标签 123uls = html.xpath('//ul')for ut in uls: print_result(ut) 获取&lt;li class=”item-1”>标签 123li_items_1 = html.xpath("//li[@class='item-1']")for li_item_1 in li_items_1: print_result(li_item_1) 获取所有&lt;li class=”item-1”>中a标签中的链接 123li_items_1_as_href = html.xpath("//li[@class='item-1']/a/@href")for li_items_1_a_href in li_items_1_as_href: print(li_items_1_a_href) 获取所有a标签中的文字 123as_text = html.xpath("//a/text()")for a_text in as_text: print(a_text)]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3中的Urllib库的使用]]></title>
    <url>%2F190615%2F</url>
    <content type="text"><![CDATA[在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。 在此处，使用Python3做记录。 urlopen函数urlopen函数是request中的一个很常用的函数，它主要用于打开一个网页。其中有着很多的属性。 1234from urllib import requestresp = request.open("https://www.baidu.com")print(resp.read()) urlretrieve函数urlretrieve函数可以很方便的将网页保存至本地。其实用方法见下方代码： 123from urllib import requestrequest.urlretrieve() urlencode函数将字典类型的数据转化为url编码的数据 123456789from urllib import parse, requestparams = &#123;"wd": "爬虫之道"&#125;qs = parse.urlencode(params)url = f"https://www.baidu.com/s?&#123;qs&#125;"resp = request.urlopen(url) parse_qs函数将url编码后的参数还原为字典形式，其中的值以列表形式进行存储。 12345678from urllib import parseps = &#123;"name": "爬虫之道", "vxcode": "spider_rold"&#125;results = parse.urlencode(ps)new_results = parse.parse_qs(results)print(new_results) urlparse和urlsplit函数对URL各部分进行分割，其中在使用urlsplit函数时，没有params参数。（注：params参数指的是在以下链接中”?”前添加”;”，位于这两者之间的内容，如：https://www.baidu.com/s;hello?wd=hello+world） 123456789101112131415from urllib import parseparams = &#123;"wd": "爬虫之道"&#125;qs = parse.urlencode(params)url = f"https://www.baidu.com/s?&#123;qs&#125;"result = parse.urlparse(url)print('scheme:', result.scheme)print('netloc:', result.netloc)print('path:', result.path)print('params:', result.params)print('query:', result.query)print('fragment:', result.fragment) request.Request类在爬虫中，如果想使用一些参数，如：请求头，请求数据等，需要使用到Request类。如果只是使用urlopen函数，没有办法进行添加请求头。在没有使用User-Agent的时候，如果服务器发现是爬虫，服务器可能会返回一条假的数据内容，或者是不返回内容。所以，将爬虫程序伪装成正常的浏览器访问是很有必要的一件事。 1234567891011from urllib import request, parseheaders = &#123;'user-agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36"&#125;params = &#123;"wd": "爬虫之道"&#125;qs = parse.urlencode(params)url = f"https://www.baidu.com/s?&#123;qs&#125;"req = request.Request(url, headers=headers)resp = request.urlopen(req)print(resp.read()) 注： 可以去挑战一下网络爬虫界的“珠穆朗玛峰” —– 拉勾网 ProxyHandler处理器在爬取网站时，一般情况下网站都会做一些反爬虫机制，如封ip。如果只使用一个ip地址进行爬取，在网站封掉ip地址后，就无法获取数据了。所以，在有反爬虫机制的情况，反反爬虫机制便可以使用了。在urllib中通过使用ProxyHandler进行设置代理服务器。 在使用代理与未使用代理的区别： 12345678910111213from urllib import request### 未使用代理resp = request.urlopen('http://httpbin.org/get')print(resp.read())### 使用代理handler = request.ProxyHandler(&#123;"https": "58.253.152.231:9999"&#125;)opener = request.build_opener(handler)req = request.Request("http://httpbin.org/get")resp = opener.open(req)print(resp.read()) 常用的代理： 西刺代理：https://www.xicidaili.com 快代理: https://www.kuaidaili.com/free/ Cookie是什么在网站汇总，http请求是无状态的。在第一次和服务器建立连接登录后，第二次请求服务器依旧不能知道当前请求的用户是谁。Cookie的出现就是为了解决该问题。第一次登录后，服务器会返回一些数据(cookie) 给浏览器，然后浏览器将数据保存在本地。当用户发送第二次请求时，浏览器会自动的将保存在本地的数据(cookie)一起发送给服务器。服务通过判断不同的cookie信息，进行确认用户。cookie的存储大小是有限的一般不会超过4KB，因此在设置cookie对的时候，只能存储少量数据。 cookie的格式：Set-Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE 参数含义： NAME：Cookie的名字 VALUE：Cookie的值 Expires: Cookie的过期时间 Path：Cookie作用的路径 Domain： Cookie作用的域名 SECURE：是否只在HTTP协议下起作用 使用cookielib库和HTTPCookieProcessor模块模拟登陆在Python中使用cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器一起使用的。 http.cookiejar：提供用于存储cookie的对象 HTTPCookieProcessor：处理cookie对象并构建handler对象 http.cookiejar模块在该模块中主要有三个类，CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。其作用如下： CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie失效。 FileCookieJar (filename, delayload=None, policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例。检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名，delayload为True是支持延迟访问文件，即只有在需要时才读取文件或将数据存储在文件中。 MozillaCookieJar (filename, delayload=None, policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename, delayload=None, policy=None)：从FileCookieJar派生而来，创建与libwww·per标准的Set-Cookies3文件格式兼容的FileCookieJar实例。 保存Cookie至本地保存cookie到本地，可以使用cookiejar的save方法。 1234567891011121314151617from urllib import requestfrom http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar('cookies.txt')handler = request.HTTPCookieProcessor(cookiejar)opener = request.build_opener(handler)handlers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36',&#125;req = request.Request('http://httpbin.org/cookies', headers=handlers)resp = opener.open(req)print(resp.read())cookiejar.save(ignore_discard=True, ignore_expires=True) 加载本地cookie从本地文件读取cookie信息，可以使用cookiejar中的load方法 123456from http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar('cookies.txt')cookiejar.load(ignore_discard=True)for cookie in cookiejar: print(cookie)]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Next加上彩色标签云]]></title>
    <url>%2F190520%2F</url>
    <content type="text"><![CDATA[最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（传送门），在此也做下记录吧！ 打开themes –> next –> layout –> page.swig文件 找到{ % if page.type === &#39;tags&#39; % } 将下方代码进行替换即可 123456789原内容：&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;% if not theme.tagcloud %&#125; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &#123;% else %&#125; &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125; &#123;% endif %&#125;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748修改之后的内容：&lt;div class=&quot;tag-cloud-tags&quot; id=&quot;tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &apos;#fff&apos;, end_color: &apos;#fff&apos;&#125;) &#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;script type=&quot;text/javascript&quot;&gt; var alltags=document.getElementById(&apos;tags&apos;); var tags=alltags.getElementsByTagName(&apos;a&apos;); for (var i = tags.length - 1; i &gt;= 0; i--) &#123; var r=Math.floor(Math.random()*75+130); var g=Math.floor(Math.random()*75+100); var b=Math.floor(Math.random()*75+80); tags[i].style.background = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;; &#125;&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; div#posts.posts-expand .tag-cloud a&#123; background-color: #f5f7f1; border-radius: 6px; padding-left: 10px; padding-right: 10px; margin-top: 18px; &#125; .tag-cloud a&#123; background-color: #f5f7f1; border-radius: 4px; padding-right: 5px; padding-left: 5px; margin-right: 5px; margin-left: 0px; margin-top: 8px; margin-bottom: 0px;&#125; .tag-cloud a:before&#123; content: &quot;&quot;; &#125; .tag-cloud-tags&#123; text-align: left; counter-reset: tags; &#125;&lt;/style&gt; 之后清理缓存，重新部署就行了。 最终效果如下：]]></content>
      <categories>
        <category>起始篇</category>
      </categories>
      <tags>
        <tag>标签云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那天一切都结束了]]></title>
    <url>%2F190517%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19FQHHWkiMt+bkOYNOHw/PDheyL1Ejr1qZSL50mkvh8+h0vMFqr/oTExN7WEYAy/v698u37/g7WnyW8QGg7sbr8fqkqAx17Gq3PyYVy+Fbe7eGu23FjN9T3xP9LdrSforX9z0LaAxb5SGpa4keun2sTobryWEHJkLMYwlvDSZB7JXGZPgBbaOVoFDPJR1iTvabKloYxribQmpEozD+L3vhbgd2P6XirMTG58xU0F/de3s/gz2uF5dIE1iKxYI9CEdyeK4WLq+OyOgN9QwKtFZ8R8w9l0hC9L7QWpiadkBEwwMLqNUKUh0oAJ9lyvDA8kYg74yCVL563i35W6gta0B2opyPV/2JaeE0E5c215UWa7dSBWlNGLUQpQ5l0PyDbAENfXaWbQqRFda+vo4tVRyvcYYP2rqVaI1x0Ua0x9khjnoNse/wf8OUYb6vPz7lZySuZURlHlvwmozNEiHVR5mH87Zx64h5HrP+8DLz9eCdO1/s12Bem+0U9yUkie8suQZpoll7Lgx3yffjt0FdXWKbprqLb16Pq5qOa48TqZca5WWpk4tMBJ697PcSz4X0KHfnn5yM8Lx6OFvo3rJTIKN0KecACUqXiwPaeztGqCrVFoJ4rfPPoc8IG2xLilJX6BUrkN8IhKDTTkrArK9Kjmm6r/vZTolS2GscEBliff6qczF5i5Ed6B4P7nmpsEFV3fgGUTYyO0VuuvbkCgkvsje7cv7ZUVCn/ykvUSRI7xqlCAFS9lbN02nkgIVdkUAi+0M2xoeRw/IOiSVJNFbCUgiMpDZbL87tuYUE7yEKhoRjdrrcceRKdhdHtTSqkwxtELXOj+QehBnho1g== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>往事回廊</category>
      </categories>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Cython保护Python文件]]></title>
    <url>%2F190502-4%2F</url>
    <content type="text"><![CDATA[使用Cython保护Python代码库从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux/Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式： (推荐) 通过setup.py中调用Cython.Build进行编译 使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件 在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库 使用Jupyter Notebook或者Sage Notebook直接运行Cython代码 这上面四种方法里最简单的是第三种方法。运行cythonize -i &lt;.pyx File&gt;即可编译.pyx成二进制库，并保存在与.pyx文件相同的目录下。cythonize命令有其他的参数，可以通过命令行查看。这个命令也可以通过python -m Cython.Build.Cythonize -i &lt;.pyx File&gt;来完成。 在对Python 代码进行保护时，可以采用Cython对Python代码记性二进制转换，尽管可以对二进制文件进行逆向工程，但是依然会起到一定的保护作用. 对项目包进行编译对以下结构的包进行编译: 通过setup.py文件进行简单编译 在使用该方法编译的时候，一个函数只有一个参数时，有可能会出现无法找到函数的情况，鉴于这种情况，请参考复杂编译的过程。以Cython官方实例为例： setup.py文件： 1234567from distutils.core import setupfrom Cython.Build import cythonizesetup( name = 'Hello world app', ext_modules = cythonize("hello.py"),) hello.py文件： 12def say_hello_to(name): print("Hello %s!" % name) 运行python setup.py build_ext --inplace，生成.so文件，删除该文件夹中的py文件和c文件。在终端导入使用： 使用setup.py文件进行复杂编译 12345678910111213141516171819202122from setuptools import setupfrom setuptools.extension import Extensionfrom Cython.Build import cythonizefrom Cython.Distutils import build_extsetup( ext_modules=cythonize( [ Extension('mypkg.*', ['mypkg/*.py']), Extension('mypkg.submypkg1.*', ['mypkg/submypkg1/*.py']), Extension('mypkg.submypkg2.*', ['mypkg/submypkg2/*.py']), Extension('mypkg2.*', ['mypkg2/*.py']), ], build_dir='build', compiler_directives=dict( always_allow_keywords=True ) ), cmdclass = dict( build_ext=build_ext ),) 结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.├── build│ ├── mypkg│ │ ├── bar.c│ │ ├── foo.c│ │ ├── __init__.c│ │ ├── submypkg1│ │ │ ├── bar.c│ │ │ ├── foo.c│ │ │ └── __init__.c│ │ └── submypkg2│ │ ├── bar.c│ │ ├── foo.c│ │ └── __init__.c│ ├── mypkg2│ │ ├── bar.c│ │ ├── foo.c│ │ └── __init__.c│ └── temp.linux-x86_64-3.7│ └── build│ ├── mypkg│ │ ├── bar.o│ │ ├── foo.o│ │ ├── __init__.o│ │ ├── submypkg1│ │ │ ├── bar.o│ │ │ ├── foo.o│ │ │ └── __init__.o│ │ └── submypkg2│ │ ├── bar.o│ │ ├── foo.o│ │ └── __init__.o│ └── mypkg2│ ├── bar.o│ ├── foo.o│ └── __init__.o├── mypkg│ ├── bar.cpython-37m-x86_64-linux-gnu.so│ ├── bar.py│ ├── foo.cpython-37m-x86_64-linux-gnu.so│ ├── foo.py│ ├── __init__.cpython-37m-x86_64-linux-gnu.so│ ├── __init__.py│ ├── submypkg1│ │ ├── bar.cpython-37m-x86_64-linux-gnu.so│ │ ├── bar.py│ │ ├── foo.cpython-37m-x86_64-linux-gnu.so│ │ ├── foo.py│ │ ├── __init__.cpython-37m-x86_64-linux-gnu.so│ │ └── __init__.py│ └── submypkg2│ ├── bar.cpython-37m-x86_64-linux-gnu.so│ ├── bar.py│ ├── foo.cpython-37m-x86_64-linux-gnu.so│ ├── foo.py│ ├── __init__.cpython-37m-x86_64-linux-gnu.so│ └── __init__.py├── mypkg2│ ├── bar.cpython-37m-x86_64-linux-gnu.so│ ├── bar.py│ ├── foo.cpython-37m-x86_64-linux-gnu.so│ ├── foo.py│ ├── __init__.cpython-37m-x86_64-linux-gnu.so│ └── __init__.py└── setup.py 运行文件python setup.py build_ext --inplace 最终会在当前文件夹中生成build文件夹，同时在build文件夹中生成相应的文件夹和.c文件，在主目录对应的文件夹中生成.so文件，此时的.so文件就可以通过导入的方式直接使用。 如果需求有改动，需要删除相应的.so文件后重新生成该文件。 注意事项： 此always_allow_keywords=True参数一定要添加，因为always_allow_keywords指令禁用具有大量参数的函数只允许使用关键字参数，如果不禁用，此处在传入一个参数时会找不到对应的函数。 在使用第二种方法时，一定要注意一点，在有celery task任务的文件中，无法进行编译，否则在编译过后会出现celery无法启动的情况。 对上文出现的问题进行给出一个解答：在上文中，如果编译了带有task任务的文件，会出现以下错误 1AttributeError: 'method-wrapper' object has no attribute '__module__' 解决方法为： 创建第三方真实执行逻辑的文件，在进行加密时，加密第三方逻辑文件，对celery调度任务的文件不进行加密。 见官方给出的解决方式Issues，不过此处不建议更改celery源文件。 参考链接： Using Cython to protect a Python codebase 对《Using Cython to protect a Python codebase》的翻译 Cython Documentation]]></content>
      <categories>
        <category>Cython</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>Cython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL学习总结]]></title>
    <url>%2F190502-3%2F</url>
    <content type="text"><![CDATA[PG数据库：理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库中，用户可以指定表集合，这点和mongodb很像。 模式(架构)：是指定的表集合，它还可以包含视图、索引、序列、数据类型、运算符和函数. 1创建模式:create schema &lt;schemaname&gt; 架构作用: 1、模式有助于多用户使用一个数据库,而不会互相干扰 2、将数据库对象组织成逻辑组,使其更易于管理 3、可以将第三方模式放入单独的模式中,以避免与其他对象的名称相冲突 PostgreSQL中的连接类型： 内连接（inner join）显示两个集合共有部分（交集） select table1.columns,table2.columns from table1 inner join table2 on table1.common_filed = table2.common_filed; 左外连接（left outer join）显示左集合的全部，右集合不满足的用空补全 select table1.columns,table2.columns from table1 left outer join table2 on table1.common_filed = table2.common_filed; 右外连接（right outer join）显示右集合的全部，左集合不满足的用空补全 select table1.columns,table2.columns from table1 right outer join table2 on table1.common_filed = table2.common_filed; 全连接（full outer join）显示两个集合的全部，不满足条件的用空补全 select table1.columns,table2.columns from table1 full outer join table2 on table1.common_filed = table2.common_filed; 跨连接（cross join）将第一个表的每一行与第二个表的每一行相匹配。 select coloums from table1 cross join table2; having子句和group by子句组合使用，用于选择函数结果满足某些条件的特定行。 普通用户创建与登陆： 1、登陆超级用户：sudo -u postgres psql 2、创建用户：create user dbuser encrypted password ‘test’; 3、授权：alter user dbuser with createdb; alter user dbuser with login; 4、创建dbuser用户的数据集：create database dbusers with owner=’dbuser’; 5、退出\q 6、普通用户登陆：psql -U dbuser -d dbusers -h localhost 触发器123456create or replace function auditlogfunc() returns trigger as $example_table$begin insert into audit(emp_id,entry_date) values (new.ID, current_timestamp); return newend;$example_table$ language plpgsql; 1create trigger example_trigger after insert on company for each row execute procedure auditlogfunc(); PostgreSQL触发器目的： 1、验证输入数据 2、执行业务规则 3、为不同文件中新插入的行生成唯一值 4、写入其他文件以急性审计跟踪 5、从其他文件查询交叉引用目的 6、访问系统函数 7、将数据复制到不同的文件以实现数据一致性 触发器的查询、删除： 列出当前数据库的所有触发器：select * from pg_trigger; 列出某张表上的触发器：SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid=pg_class.oid AND relname=’\‘; 删除触发器：drop trigger &lt;trigger_name&gt;; 查询创建的函数：1234567891011SELECT pg_proc.proname AS "函数名称", pg_type.typname AS "返回值数据类型", pg_proc.pronargs AS "参数个数" FROM pg_proc JOIN pg_type ON (pg_proc.prorettype = pg_type.oid) WHERE pg_type.typname != 'void' AND pronamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE nspname = 'public'); 索引用于加速从数据库中检索数据 创建索引:create index index_name on table_name; 响应时间的计算模型：响应时间=网络传输时间（请求）+服务器处理时间（一层或是多层）+网络传输时间（响应）+页面前段解析时间]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习总结]]></title>
    <url>%2F190502-2%2F</url>
    <content type="text"><![CDATA[git整理： 工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git commit将文件提交到本地仓库，git push将文件提交到远程仓库。 历史版本回退及提交至远程仓库123456git reset --hard HEAD^ 可以回退版本 当回退多个版本时可以使用 HEAD~100（恢复到第100个版本）。git reflog 用于记录每次的命令，最上方为最近一次的命令git reset HEAD &lt;file&gt; 将缓存区中的修改回退到工作区。git checkout -- &lt;file&gt; 将版本库中的版本替换工作区的版本，可以做恢复用。git push 将当前分支master推送到远程git commit 将缓存区中的文件推送到分支master(本地) 分支的创建、切换与合并12345git checkout -b &lt;branch&gt; 创建一个分支并切换，等同于git branch &lt;branch&gt; git checkout &lt;branch&gt;两条命令git branch 查看当前分支git merge 命令用于合并指定分支到当前分支git branch -d &lt;branch&gt; 删除分支git log --graph 可以查看分支合并图 对远程分支进行操作1git push origin --delete branch &lt;branchname&gt;或git push origin :&lt;branchname&gt; 删除远程仓库中的分支 重命名远程分支：1、删除远程分支：git push –delete origin 2、重命名本地分支：git branch -m 3、推送本地分支：git push origin 提交出错解决方法如果在提交远程仓库的时候出现“更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支”，此时应该先获取远程更新,然后合并本地的分支，最后提交. 123456git fetch origin; # 获取运程仓库git merge origin/master # 将本地仓库与远程仓库合并git pull = git fetch + git merge 可能会产生冲突，需要手动解决--no-ff 参数表示禁用Fast forward 如果出现”您要求从远程 ‘origin’ 拉取，但是未指定一个分支。因为这不是当前分支默认的远程仓库，您必须在命令行中指定一个分支名。”执行以下内容：git branch --set-upstream-to corigin/master master 出错时出错内容:1234error: failed to push some refs to &apos;https://github.com/bnq456/bnq456.github.io.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again. 强制推送在确定自己仓库中的内容低于本地仓库中的内容并且确定本地优于远程时，如果无法进行推送，可以选择强制推送git push -u origin master -f push前先将远程repository修改pull下来 12git pull origin mastergit push -u origin master 若不想merge远程和本地修改，可以先创建新的分支： 123git branch [name]然后pushgit push -u origin [name] fetch 和 pull的区别：123456git fetch：将远程主机的最新内容拉取到本地，是否合并由用户决定。git pull：将远程主机的最新内容拉取到本地后直接合并，可能会产生冲突，需要手动解决。解决方法：git reset --hard FETCH_HEADgit pull注：将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或HEAD，还需要--hard。当后面没有hard，不会冲掉本地工作区，只会冲掉stage区。 Git中工作环境的临时存储与恢复12345git stash 把当前工作现场存储起来，用于以后恢复现场继续工作切换回工作时： git stash list 列出所有存储的工作环境result: stash@&#123;0&#125;: WIP on dev: cc559a8 add mergegit stash pop 切回工作场景，或git stash apply stash@&#123;0&#125; 恢复后不删除stash中的内容，需要使用git stash drop &lt;name&gt;删除 pop和 apply的区别pop是将工作环境切回后直接删除apply是先应用工作环境，然后存储的工作环境是否删除由用户自己决定。使用：git stash drop 进行删除 实验性质的代码最好新建分支 分支的创建、删除、合并与推送1234567891011git branch &lt;branchname&gt;git checkout &lt;branchname&gt;以上两条命令等同于git checkout -b &lt;branchname&gt;git branch -D &lt;name&gt; 表示强行删除一个分支git merge &lt;branchname&gt; 分支的合并，表示要将&lt;branchname&gt;分支合并到当前分支上分支的推送：master分支是主分支，因此要时刻与远程同步;dev分支是开发分支，团队所有成员都需要在上面工作，所以需要时刻与远程同步;bug分支是本地修复bug，可推送可不推送;feature分支取决与是否在上面进行开发。 多人协作： 1、首先，可以试图用git push origin 推送自己的修改； 2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 3、如果合并有冲突，则解决冲突，并在本地提交； 4、没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 5、如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/。 rebase：（不是很了解） rebase操作可以将本地未push的分叉提交历史整理成一条直线;rebase的目的是使我们在查看提交的变化时更容易，因为分叉的提交需要三方比较。 git 标签：git tag 用于新建一个标签,默认为HEAD，当创建带有说明的标签时，用-a指定标签名，-m指定说明文字git tag可以查看所有的标签当给以前忘记打标签的项目打标签时，可以先找出要打标签项目的编号，然后git tag -d用于删除标签 远程标签推送： git push origin 推送一个本地标签到远程 git push origin –tags 将所有标签推送到远程 123当删除远程标签时：1、首先先删除本地的标签 git tag -d &lt;tagname&gt;2、然后删除远程的标签 git push origin :refs/tags/&lt;tagname&gt;或者git push origin --delete tag &lt;tagname&gt;（作用与上两步相同） 日志文件查询1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习总结]]></title>
    <url>%2F190502-1%2F</url>
    <content type="text"><![CDATA[Docker 中的三个基本概念 镜像(Image) 容器(Container) 仓库(Repository) 镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 镜像不包含任何动态数据，其内容在构建之后也不会改变 容器是镜像的运行时实例 - 实际执行时镜像会在内存中变成什么。默认情况下，它完全独立于主机环境运行，仅在配置为访问主机文件和端口的情况下才执行此操作。 命令1234567891011121314151617181920212223242526272829303132333435docker build -t friendlyname .# 使用此目录的 Dockerfile 创建镜像docker run -p 4000:80 friendlyname # 运行端口 4000 到 90 的“友好名称”映射docker run -d -p 4000:80 friendlyname # 内容相同，但在分离模式下docker ps # 查看所有正在运行的容器的列表docker stop &lt;hash&gt; # 平稳地停止指定的容器docker ps -a # 查看所有容器的列表，甚至包含未运行的容器docker kill &lt;hash&gt; # 强制关闭指定的容器docker rm &lt;hash&gt; # 从此机器中删除指定的容器docker rm $(docker ps -a -q) # 从此机器中删除所有容器docker images -a # 显示此机器上的所有镜像docker rmi &lt;imagename&gt; # 从此机器中删除指定的镜像docker rmi $(docker images -q) # 从此机器中删除所有镜像docker login # 使用您的 Docker 凭证登录此 CLI 会话docker tag &lt;image&gt; username/repository:tag # 标记 &lt;image&gt; 以上传到镜像库docker push username/repository:tag # 将已标记的镜像上传到镜像库docker run username/repository:tag # 运行镜像库中的镜像docker stack ls # 列出此 Docker 主机上所有正在运行的应用docker stack deploy -c &lt;composefile&gt; &lt;appname&gt; # 运行指定的 Compose 文件docker stack services &lt;appname&gt; # 列出与应用关联的服务docker stack ps &lt;appname&gt; # 列出与应用关联的正在运行的容器docker stack rm &lt;appname&gt; # 清除应用docker-machine create --driver virtualbox myvm1 # 创建 VM（Mac、Win7、Linux）docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10docker-machine env myvm1 # 查看有关节点的基本信息docker-machine ssh myvm1 "docker node ls" # 列出 swarm 中的节点docker-machine ssh myvm1 "docker node inspect &lt;node ID&gt;" # 检查节点docker-machine ssh myvm1 "docker swarm join-token -q worker" # 查看加入令牌docker-machine ssh myvm1 # 打开与 VM 的 SSH 会话；输入“exit”以结束会话docker-machine ssh myvm2 "docker swarm leave" # 使工作节点退出 swarmdocker-machine ssh myvm1 "docker swarm leave -f" # 使主节点退出，终止 swarmdocker-machine start myvm1 # 启动当前未运行的 VMdocker-machine stop $(docker-machine ls -q) # 停止所有正在运行的 VMdocker-machine rm $(docker-machine ls -q) # 删除所有 VM 及其磁盘镜像docker-machine scp docker-compose.yml myvm1:~ # 将文件复制到节点的主目录docker-machine ssh myvm1 "docker stack deploy -c &lt;file&gt; &lt;app&gt;" # 部署应用 Docker命令12345678910111213docker save -o &lt;localfilename&gt; &lt;flename&gt; #导出镜像到本地文件docker load --input &lt;filename&gt; #从导出的本地文件中再导入到本地镜像库docker load &lt; &lt;filename&gt; #同上，导入镜像以及其相关的元数据信息(包括标签等)(生成镜像文件)docker run -d ... # 使docker容器在后台以守护态形式运行docker export &lt;container id&gt; &gt; &lt;localfilename&gt; # 将本地的某个容器导出docker import - &lt;repository:tag&gt; # 将容器快照文件导入为镜像 (生成镜像快照)docker load 和 docker import 的区别： docker import 将丢弃所有的历史记录和元数据信息(仅保存容器当时的快照状态)， docker load 将保存完整记录，体积较大 docker import 导入时可以重新指定标签等元数据信息docker image ls --digests # 列出所有镜像的摘要docker image rm &lt;id、repository:tag&gt; # 删除镜像，在通过id删除时，可以指定前3个字符以上，但是要能足够用于区分别的镜像docker image rm &lt;digest&gt; # 精确删除 Union FS 是有最大层数限制的,比如 AUFS，一个镜像不能超过127层 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 仓库名、标签均为&lt;none&gt;的镜像，被称为虚悬镜像 显示虚悬镜像：docker image ls -f dangling=true 删除虚悬镜像：docker image prune docker 中的过滤器在docker image ls还支持使用过滤器参数 –filter或-f since 在某个镜像之后建立的镜像 before在某个镜像之前建立的镜像 dangling未打开标签 镜像是多层存储,每一层是在前一层的基础上进行的修改;而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。 镜像的定制实际上就是定制每一层所添加的配置、文件. 在构建Dockerfile时，如果使用了scratch为基础镜像，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始，这样减少了镜像体积。 从标准输入中读取Dockerfile123docker build - &lt; Dockerfile或cat Dockerfile | docker build - 如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，它没有上下文，因此不以像其他方法那样将文本文件Copy进镜像之类的事情 ADD中更高级的复制文件ADD指令将会自动解压缩这个压缩文件到&lt;目标路径&gt; COPY和ADD指令选择时遵循的原则所有文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD Docker 不是虚拟机,容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,用upstart/systemd 去启动后台服务,容器内没有后台服务的概念。启动程序就是容器应用进程,容器就是为了主进程而存在的,主进程退出,容器就失去了存在的意义。当使用ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT。 EXPOSE指令是声明运行时容器提供的服务端口 WORKDIR可以来指定工作目录(或者称为当前目录)，以后各层的当前目录就被改为指定的目录，如果目录不存在，WORKDIR自动创建目录。 USER和WORKDIR都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的执行RUN、CMD以及ENTRYPOINT这类命令的身份。 HEALTHCHECK支持下列选项: –interval=&lt;间隔&gt; :两次健康检查的间隔,默认为 30 秒; –timeout=&lt;时长&gt; :健康检查命令运行超时时间,如果超过这个时间,本次健康检查就被视为失败,默认 30 秒; –retries=&lt;次数&gt; :当连续失败指定次数后,则将容器状态视为unhealthy,默认3次。 CMD、ENTRYPOINT、HEALTHCHECK三者的共同点：在Dockerfile文件中只可以出现一次，如果出现多次，只有最后一个生效。 镜像迁移123docker export container_id &gt; export_filename.tarcat export_filename.tar | docker import - repository:tag 此处利用了Linux中的管道，将一个镜像文件从一台机器迁移到另一台机器 docker attach和docker exec的区别相同点： 两者都可以使用-d、-i参数，在同时使用这两个参数时，都是进入bash -i参数是没有分配伪终端，但命令执行结果仍然返回 不同点： 在使用attach进入伪终端，输入exit退出时，会导致容器的停止 exec进入终端，输入exit退出时，不会导致容器的停止 容器的操作12docker container rm 容器名称docker container prune # 清理所有处于终止状态的容器 如果要删除一个运行中的容器,可以添加-f参数。Docker 会发送SIGKILL信号给容器。 Docker 数据管理在容器中管理数据主要有两种方式： 数据卷(Volumes) 挂载主机目录(Bind mounts) 数据卷数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性： 数据卷可以在同期之间共享和重用 对数据卷的修改会立即生效 对数据卷的更新，不会影响镜像 数据卷默认一直存在，即使容器被删除 数据卷操作命令1234docker volume create &lt;volumename&gt; # 创建一个数据卷docker volume ls # 查看所有数据卷docker inspect &lt;contrainer name&gt; # 查看容器的信息docker volume rm &lt;volumename&gt; # 删除数据卷 在用docker run命令的时候，使用 –mount标记来将数据卷挂载到容器里，在一次docker run中可以挂载多个数据卷。 数据卷是被设计用来持久化数据的，它的声明周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收机制。 使用网络在容器中运行一个网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来执行端口映射 在使用-P标记时，Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。 Compose中的两个重要概念 服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义 docker-compose命令命令选项 -f, –file FILE 指定使用的 Compose 模板文件,默认为docker-compose.yml,可以多次指定。 -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 –x-networking 使用Docker的可拔插网络后端特性 –x-network-driver DRIVER 指定网络后端的驱动，默认为bridge –verbose 输出更多调试信息 -v, –version打印版本并退出]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫之urllib模块]]></title>
    <url>%2F190502%2F</url>
    <content type="text"><![CDATA[Python2 中的urllib和Python3中的urlllib的区别在python 2中有urllib和urllib2两个库进行实现请求的发送，但是再python 3中官方将urllib2库合并在了urllib库中。所以在3中使用urllib库时一定要先了解其中的四个模块： request：这个模块是最基本的HTTP请求模块，用来模拟发送请求。 error：异常处理模块，用来捕获异常，保证程序不会意外终止。 parse：工具模块，提供了许多URL处理方法，如拆分、解析、编码等 robotparser:用来识别网站的robots.txt文件，判断哪些网站可以爬，一般不用。此处只讲解前三个的用法。 请求的发送1、urlopen()函数在urllib.request模块中提供了最基本的构造HTTP请求的方法，可以利用它进行模拟浏览器发送一个请求，同时它还具有处理授权验证、重定向、浏览器cookies等其他内容下面以百度为例子，进行网页的抓取：1234from urllib import requestresponse = request.urlopen(&apos;http://www.baidu.com&apos;)print(response.read().decode(&apos;utf8&apos;)) 可以很简单的看出，上面很简单的三行代码已经实现了一个简单的爬虫了。只不过这个爬虫获取下来的内容没有经过任何数据处理，我们可以很容的看到百度首页的源代码。之后，查看返回的内容是什么类型的。print(type(response))输出为：&lt;class &#39;http.client.HTTPResponse&#39;&gt;可以发现，它是一个HTTPResponse类型的对象，接下来查看有那些函数和属性，使用dir(response)：输出为:1[&apos;__abstractmethods__&apos;, &apos;__class__&apos;, &apos;__del__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__eq__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__next__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;_abc_impl&apos;, &apos;_checkClosed&apos;, &apos;_checkReadable&apos;, &apos;_checkSeekable&apos;, &apos;_checkWritable&apos;, &apos;_check_close&apos;, &apos;_close_conn&apos;, &apos;_get_chunk_left&apos;, &apos;_method&apos;, &apos;_peek_chunked&apos;, &apos;_read1_chunked&apos;, &apos;_read_and_discard_trailer&apos;, &apos;_read_next_chunk_size&apos;, &apos;_read_status&apos;, &apos;_readall_chunked&apos;, &apos;_readinto_chunked&apos;, &apos;_safe_read&apos;, &apos;_safe_readinto&apos;, &apos;begin&apos;, &apos;chunk_left&apos;, &apos;chunked&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;code&apos;, &apos;debuglevel&apos;, &apos;detach&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;fp&apos;, &apos;getcode&apos;, &apos;getheader&apos;, &apos;getheaders&apos;, &apos;geturl&apos;, &apos;headers&apos;, &apos;info&apos;, &apos;isatty&apos;, &apos;isclosed&apos;, &apos;length&apos;, &apos;msg&apos;, &apos;peek&apos;, &apos;read&apos;, &apos;read1&apos;, &apos;readable&apos;, &apos;readinto&apos;, &apos;readinto1&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;reason&apos;, &apos;seek&apos;, &apos;seekable&apos;, &apos;status&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;url&apos;, &apos;version&apos;, &apos;will_close&apos;, &apos;writable&apos;, &apos;write&apos;, &apos;writelines&apos;] 其中最主要函数为：read()、readinto()、getheader(name)、getheaders()、fileno()等方法。在调用read()方法时可以返回网页内容，使用status属性可以查看返回的状态码。在urlopen()方法中，最基本的是简单网页的GET请求抓取。但是如果要传入一个参数呢？下面就讲解参数的使用方法。 data参数在讲解之前，首先需要说明的是data参数是可选的，如果传入了此参数，要以字节流编码格式的内容，即bytes类型，需要进行转化。此时的请求方式不再是GET方法，而是POST方法.因为如果使用GET方法，会将传入data暴露在url中，十分不安全。实例一: 12345from urllib import request, parsedata = bytes(parse.urlencode(&#123;&apos;word&apos;: &apos;hello world&apos;&#125;), encoding=&apos;utf8&apos;)response = request.urlopen(&apos;http://httpbin.org/post&apos;, data=data)print(response.read().decode(&apos;utf8&apos;)) 这里我们传入了一个参数word，值为hello world。由于发送的的data需要是字节流类型，此处使用到了上文提到的工具包函数parse，使用它将我们要传入的函数进行转码。在我们执行完这段代码后，服务器会给我们返回一下结果: 12345678910111213141516171819&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;word&quot;: &quot;hello world&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept-Encoding&quot;: &quot;identity&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;16&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;115.60.58.52&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125; 此时我们可以很容易的看到，在返回的结果中有form字段，字段中的内容就是我们传入的data中的内容，至此我们已经模拟了表单提交的过程，以POST请求方式尽心传输数据。 timeout参数顾名思义，这个参数就是用来设置超时的。单位为秒，意思是当请求超出了设置的值后还有得到响应，就讲异常抛出。如果此参数不指定时间，使用全局默认时间。实例：1234from urllib import requestresponse = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)print(response .read().decode(&apos;utf8&apos;)) 运行结果： 12345678910111213141516Traceback (most recent call last): File &quot;test_urllib_001.py&quot;, line 14, in &lt;module&gt; response = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 222, in urlopen return opener.open(url, data, timeout) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 525, in open response = self._open(req, data) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 543, in _open &apos;_open&apos;, req) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 503, in _call_chain result = func(*args) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1345, in http_open return self.do_open(http.client.HTTPConnection, req) File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1319, in do_open raise URLError(err)urllib.error.URLError: &lt;urlopen error timed out&gt; 这里我们设置了超时的时间是0.1秒。程序再执行0.1秒以后，服务器依然没有任何响应，于是抛出了URLError异常。可以从&lt;urlopen error timed out&gt;看出是网络超时。那么问题来了，如何抓取这种情况呢？实例： 12345678from urllib import request, errorimport sockettry: response = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)except error.URLError as e: if isinstance(e.reason, socket.timeout): print(&apos;Time Out&apos;) 我们用try: … except: …来捕获异常，此处引入了socket模块。 2、Request到此，我们知道了如何用urlopen方法实现一个简单的请求发送。但是这些简单参数有时候并不能满足我们的需求，比如我们需要在请求中添加header，此时就需要一个更加强大的类来实现了，这就是本节要讲的Request类。实例是最好的验证。实例：12345from urllib import requestreq = request.Request(&apos;https://baidu.com&apos;)response = request.urlopen(req)print(response.read().decode(&apos;utf-8&apos;)) 此处我们依然使用了上文的urlopen()方法，只是此时的参数不再是一个URL了，而是一个Request对象。另外，这个函数我们可以很灵活的配置我们需要的参数。看下它的构造方法吧：urllib.request.Request(url, data=None, headers={},origin_req_host=None, unverifiable=False,method=None) 解释下： url：请求的URL，必填项 data：字节流，请求时需要带的数据 header：请求头，在创建实例后可以通过add_header()添加 origin_req_host: 请求方的host名称或IP地址 unverifiable：表示请求是否无法是验证的，默认为False。意思是用户没有足够的权限来选择接收这个请求的结果。 method：请求是用的方法，如GET、POST等 下面实现一个多参数构建请求的例子：123456789101112131415from urllib import request, parseurl = &apos;http://httpbin.org/post&apos;headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&apos;&#125;dict = &#123; &apos;name&apos;: &quot;spider_road&quot;&#125;data= bytes(parse.urlencode(dict), encoding=&apos;utf8&apos;)req = request.Request(url=url, data=data, headers=headers, method =&apos;POST&apos;)response = request.urlopen(req)print(response.read().decode(&apos;utf8&apos;)) 我们通过四个参数四个参数构建了这个请求，运行结果如下：12345678910111213141516171819&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;name&quot;: &quot;spider_road&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept-Encoding&quot;: &quot;identity&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;16&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;115.60.58.52&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125; 异常的处理在上节中，我们简单的提到了如何对异常做出处理，但是程序在运行过程总会出现一些其他的错误，当出现这些错误时，异常处理还是很有必要做的。1、URLErrorURLError类来自于urllib库的error模块，继承自OSError类，由request模块产生的异常都已使用这个类来捕捉。实例：123456from urllib import request, errortry: response = request.urlopen(&apos;https://spider-road.com&apos;)except error.URLError as e: print(e.reason) 上面的程序我们使用它打开了一个不存在的网址，我们使用try:… except:…来捕获了异常。运行输出：[Errno -2] Name or service not known，此时有效得避免了程序异常终止。 2、HTTPError它是URLError的子类，用来处理HTTP请求错误，比如认证请求失败等。它有一下3个属性： code： http状态码 reason：错误原因 headers： 返回请求头 实例验证：12345678from urllib import request, errortry: response = request.urlopen(&apos;https://spider-road.com&apos;)except error.HTTPError as e: print(f&apos;code:&#123;e.code&#125;\nreason:&#123;e.reason&#125;\nheaders:&#123;e.headers&#125;&apos;)except error.URLError as e: print(e.reason) 由于没有该网站，所以最后返回的是：[Errno 110] Connection timed out至此，关于urllib请求和错误处理已经讲解完毕，后续还有关于此节更为高级的用法。欢迎订阅爬虫之道，我们在这里等待你的到来。]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Centos中架设ss服务]]></title>
    <url>%2F190425%2F</url>
    <content type="text"><![CDATA[想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。 Google访问助手如果你使用的是这种方式，那么恭喜你，下面介绍的内容和你无关了。 Google访问助手下载链接：链接 架设SS服务架设环境 一台可以访问外网的VPS服务器 Centos7 + Python2.x 架设步骤 安装必须的软件包: 12345678910yum upgrade -yyum groupinstall &quot;Development Tools&quot;yum install epel-release -yyum install python-setuptools python-pip m2crypto -y## 更新pip包python -m pip install -U pip## 安装shadowsockspip install shadowsocks 创建配置文件 以下内容是创建唯一密码和端口的配置文件，如果多用户使用，建议直接使用多用户配置. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546### 单用户配置vim /etc/shadowsocks.json&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:server_port, #例如5460 &quot;local_port&quot;:1080, &quot;password&quot;:&quot;password&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125;### 多用户配置vim /etc/shadowsocks.json第一种：&#123; &quot;server&quot;:&quot;your_server_ip&quot;, # 或者使用 0.0.0.0 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; #端口号与密码 &quot;8989&quot;:&quot;password0&quot;, # 左边是端口号，右边是密码 &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125;第二种：&#123; &quot;timeout&quot;: 600, &quot;method&quot;: &quot;aes-256-cfb&quot;, &quot;port_password&quot;:&#123; &quot;40001&quot;: &quot;password1&quot;, &quot;40002&quot;: &quot;password2&quot;, &quot;40003&quot;: &quot;password3&quot; &#125;, &quot;_comment&quot;:&#123; &quot;40001&quot;: &quot;xiaoming&quot;, &quot;40002&quot;: &quot;lilei&quot;, &quot;40003&quot;: &quot;mike&quot; &#125;&#125; 系统级服务关闭 在配置完成后，需要关闭防火墙，否者会造成无法科学上网。 12systemctl stop iptablessystemctl stop firewalld 若配置完成，且防火墙关闭，依旧无法科学上网，那么看是否是浏览器设置问题，若浏览器有FQ插件且处于启用状态（浏览器启用代理），停用它。 测试是否可用 12### 开启ss服务ssserver -c /etc/shadowsocks.json start 如果可以使用，则说明配置完成 将SS服务变为系统级服务 12345678910111213vim /etc/systemd/system/shadowsocks.service### 将以下内容粘贴到打开的shadowsocks.service文件中[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 设置开机启动 1systemctl enable shadowsocks &amp;&amp; systemctl start shadowsocks 为OpenVZ的VPS服务器做BBR加速 本安装适用于CentOS/RHEL7+，Ubuntu15+，Debian8+ 的64位系统，如不是请先重装系统，下载rintd二进制文件(原版bbr和修改版bbr二选一即可) 123wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetdwget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd_bbr_powered -O /root/rinetd 最后一个为魔改版BBR，上面一个为原版。选一个下载就可以了。然后修改权限 1chmod +x rinetd 修改rinetd的配置文件rinetd.conf,添加监听地址: 123456vim rinetd.conf# bindadress bindport connectaddress connectport 0.0.0.0 443 0.0.0.0 4430.0.0.0 80 0.0.0.0 80 每一行都是一个端口，将端口改成你使用的端口就可以了。不要问我一行为什么要写两个相同的，我也不知道为什么。 将rinetd变为系统级应用 1234567891011vim /etc/systemd/system/rinetd.service[Unit]Description=rinetd[Service]ExecStart=/root/rinetd -f -c /root/rinetd.conf raw venet0:0Restart=always [Install]WantedBy=multi-user.target 设置开机启动 1systemctl enable rinetd &amp;&amp; systemctl start rinetd 在以上操作完毕后，OpenVZ架构的VPS服务器在使用SS服务时，会明显感觉到访问速度快了很多。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10中Tensorflow GPU的安装]]></title>
    <url>%2F190418%2F</url>
    <content type="text"><![CDATA[Tensorflow介绍 TensorFlow™是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。 Tensorflow2.0 GPU版的安装首先，先确定你要安装的是Tensorflow的CPU版还是GPU版。如果是CPU，请出门右转（开个玩笑）。 其次，Tensorflow分为1.x版本和2.x版本。在本文写的时候，Tensorflow刚出到2.0（preview）版本。对于本文而言，均采用pip的方式安装Tensorflow，并没有采用源码编译的方式。 如果你在pip安装的时候下载很慢，建议你pip使用阿里开源镜像源。具体配置方法为： 在阿里开源镜像中找到pypi，然后点击帮助。 打开C:\User\XXX，然后在其中创建pip文件夹，打开刚创建的pip文件夹，在其中创建pip.ini文件。最后将下方代码粘贴进去即可。 12345[global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 现在开始介绍Tensorflow的安装 CPU版的安装 如果你想安装的是Tensorflow1.x的版本，请使用pip install tensorflow 如果是Tensorflow 2.x的版本，请使用`pip install tensorflow==2.0.0-alpha0 Tensorflow GPU安装时的准备工作： 在安装以下两个文件之前，先去Tensorflow官网查看GPU安装时对CUDA和cudnn的版本要求，特别要注意标红部分。 CUDA的下载与安装 下载网址:https://developer.nvidia.com/cuda-downloads 如果当前的CUDA Toolkit版本比较高，需要选择低版本的CUDA Toolkit，请点击Legacy Releases之后选择Tensorflow官网要求的版本。 最后等待下载完毕。 要特别主要自定义中的内容。 CUDA中的内容选择 如果你不使用Visual Studio请把前面个方框中的√去掉。 NVIDIA GeForce Experience 可选可不选 Driver components 如果你当前版本高于或等于上面的新版本,那么此选项不选，如果你当前版本低于新版本，请选择。 Other components 可选可不选 最后直接点击下一步即可。 cudnn的下载与安装 cudnn的下载是需要登录的。 下载网址:https://developer.nvidia.com/cudnn 在下载cudnn的时候，要特别注意cudnn对应的cuda版本号，cuda的版本要使用Tensorflow官网要求的版本号，否者会无法使用GPU版的。注意标红的第二部分。 然后点击Windows 10即可下载。 在将cudnn下载完毕后，cudnn不是安装程序，将其解压即可，然后将文件夹名改为cudnn，最后将该文件夹移动到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0中即可。 环境变量的配置 将以下两个路径添加进系统的环境变量中，最后将刚才添加的环境变量移动到最上面。 12C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\libx64C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\cudnn\bin 验证是否可用 12import tensorflow as tftf.test.is_gpu_available() 通过以上程序，如果没有出错，则说明安装成功，如果出错，请仔细阅读以上内容。]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow知识总结]]></title>
    <url>%2F190416-1%2F</url>
    <content type="text"><![CDATA[消除过拟合的方法 L1正则化 绝对值 L2正则化 平方 L3正则化 立方 L4正则化 4次方 dropout 其中对图像的处理过程一般为:输入 – &gt; 卷积 – &gt; 池化 –&gt; 卷积 –&gt; 池化 –&gt; 消除过拟合 –&gt;全连接层 – &gt; 全连接层 –&gt; 分类 max_pool函数的作用是降低系统的复杂度，其中pooling分为最大池化和平均值池化 线性回归线性回归的目标是找到一个与训练数据最为吻合的线性函数。对于2D数据是找到一个与数据相吻合的线性函数线性回归是一种找到最适合一组点的直线或超平面的方法 在卷积运算中，对图像降维是通过修改卷积核的strides（步长）参数进行降维的。 卷积层单层CNN的实际用途是检测边缘。对于图像识别和分类任务而言，更常见的情形是使用不同的层类型支持某个卷积层。这些层有助于减少过拟合，并可加速训练过程和降低内存占用率。 tf.nn.depthwise_conv2d:将一个卷积层的输出连接到另一个卷积层的输入tf.nn.separabel_conv2d:对于较大的模型，可保证在不牺牲准确率的前提下实现训练的加速。对于较小的模型，它能够快速收敛，但准确率较低。tf.nn.conv2d_transpose:将一个卷积核应用于一个新的特征图，后者的每一部分都填充了与卷积核相同的值。当该卷积核遍历新图像时，任何重叠的部分都相加在一起。 激活函数为神经网络引入非线性 在CNN中最常用的激活函数：tf.nn.relu:Relu是分段线性的。当输入为非负数时，输出与输入相同。当输入为负数时，输出均为0.优点：不受梯度消失的影响，取值范围为[0,++]缺点：当使用较大的学习速率时，易受达到饱和的神经元的影响。 tf.sigmoid:sigmoid函数的返回值位于区间[0.0, 1.0]中。当输入值较大时，tf.sigmoid将返回一个接近于1.0的值，而输入值较小时，返回值将接近于0.0 tf.tanh:双曲正切函数(tanh)与tf.sigmoid非常接近，且后者具有类似的优缺点。tf.tanh函数的值域为[-1.0, 1.0] tf.nn.dropout:依据某个可配置的概率将输出设为0.0.为学习到的输出添加少量噪声。 梯度是偏导数的矢量Pandas 是用于进行数据分析和建模的重要库 张量(Tensor)：是对高维数据的一种抽象式表达 Tensorflow张量是什么？ 张量时用来表示多维数据的 张量时执行操作时的输入或输出数据 用户通过执行操作来创建或计算张量 张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得出。 会话是什么?会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。 会话执行: 估算张量(Tensor.eval) 执行操作(Operation.run) 会话执行(Session.run) 会话执行原理：调用sess.run(tain_op)语句执行训练操作时： 首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成了一副子图 然后，程序将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类。相同设备上的节点组成了一副局部图 最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序的加载到设备上执行。 优化算法：典型的机器学习和深度学习问题通常都需要转换为最优化问题进行求解。 求解最优化的问题的算法成为优化算法，他们通常采用迭代方式实现：首先设定一个初始的可行解。然后基于特定的函数反复重新计算可行解，直到找到一个最优解或达到预设的收敛条件。 不同的优化算法采用的迭代策略各有不同： 有的使用目标函数的一阶导数，如梯度下降法 二阶导数，如牛顿法 前几轮迭代的信息，如Adam 优化器是实现优化算法的载体：一次典型的迭代优化应该分为以下3个步骤： 计算梯度： 调用compute_gradients方法 处理梯度： 用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等 应用梯度： 调用apply_grandients方法，将处理后的梯度值应用到模型参数 Loss下降方法： 随机梯度下降 最速下降法: tf.train.AdamOptimizer() 监督学习典型算法: 线性回归（Linear Regression） 逻辑回归（Logistic Regression） 决策树（Decision Tree） 随机森林（Random Forest） 最紧邻算法（k-NN） 朴素贝叶斯（Naice Bayes） 支持向量机（SVM） 感知器（Perceptron） 深度神经网络（DNN） Tensorflow训练模型的工作流 数据读入–&gt; 数据分析 –&gt; 数据规范化 –&gt; 创建模型 –&gt; 创建会话 –&gt; 训练模型]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow的基础学习和资料]]></title>
    <url>%2F190416%2F</url>
    <content type="text"><![CDATA[测试以下内容为测试内容 以下内容未测试内容 中文测试 再次测试]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>机器学习</tag>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有些人走着走着就散了]]></title>
    <url>%2F181118%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>往事回廊</category>
      </categories>
      <tags>
        <tag>一场梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tkinter进行图片的遍历显示]]></title>
    <url>%2F190228%2F</url>
    <content type="text"><![CDATA[原因最近因为要写个GUI的内容，需要用到图像的遍历显示，因为没有办法,所以就自行摸索着开始写一个循环显示的TK。最终算是不符所望吧，勉强写出来一个，以此做下记录，便于下次使用。 12345678910111213141516171819202122232425import tkinter as tkfrom PIL import ImageTk, Imageimport glob, timeimport threadingfilenames = glob.glob('sysImages/*')def autoQuit(): time.sleep(2) root.quit()for filename in filenames: root = tk.Tk() img = Image.open(filename) photo = ImageTk.PhotoImage(img) label = tk.Label(image=photo) label.image = photo label.pack() t = threading.Thread(target=autoQuit) t.start() root.mainloop() root.destroy()]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
        <tag>遍历图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现贪心算法]]></title>
    <url>%2F180113%2F</url>
    <content type="text"><![CDATA[题目： 圣诞节来临了，在城市A中，圣诞老人准备分发糖果。现在有多箱不同的糖果，每一种糖果都有自己的价值和重量。每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果。请问圣诞老人最多能带走多大价值的糖果。 输入数据： 输入的第一行由两个部分组成，分别为糖果箱数正整数n(1&lt;=n&lt;=100)，驯鹿能承受的最大重量正整数w(0&lt;w&lt;10000)；其余n行每行对应一箱糖果，由两部分正整数v和w组成，分别为一箱糖果的价值和重量。 输出要求： 输出圣诞老人能带走的糖果的最大总价值，保留一位小数，输出为一行。 输出样例： 需要装的箱数 4 驯鹿最大承受重量 15 批次 价值 重量 1 4 15 2 100 4 3 412 8 4 266 7 5 591 2 输出样例: 1193.0 注：此处并没有按照这样的格式进行输入。 12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from __future__ import divisioninput_a = raw_input(u'箱数:')input_b = raw_input(u'最大承受重量:')list_c = []list_z = []for i in range(1,int(input_a)+1): input_c = raw_input('第'+str(i)+'箱的总价值:') input_d = raw_input('第'+str(i)+'箱的重量:') avg = round(int(input_c)/int(input_d),1)#每一箱，重量为1的价值 list_c.append(avg)#添加到列表，用于之后做比较 list_z.append([int(input_d),avg,0])#此处列表中添加列表，中间的列表一个存放总重量，第二个存放单位价值，第三个存放是否该物品已被取走list_c.sort(reverse=True) # 降序排序sum =[0,0]# 用于存放取走的总重量，第一个参数是取走的重量，第二个是超出前的备份num =0ji = 0for i in range(len(list_c)): for k in range(len(list_z)): if ji == 0:#做是否超出马车最大承受量的标记，未超出为0 if (list_c[i] == list_z[k][1]) and (list_z[k][2]==0): sum[1] = sum[0]#备份 sum[0] = sum[0] + list_z[k][0]#取走的重量 v = list_z[k][0]#取走的重量 if sum[0] &gt; int(input_b):#如果所有取走的重量超出马车的重量，就依次减少一单元的重量 ji = 1#超出为1 t= list_z[k][0] while True:#依次减去单位1的重量 z = sum[1] + t#使用备份进行判断，此时取走的数量已经大于最大承受量了 if z &lt;= int(input_b): break t = t-1 v=t#等于最大承受量时，价值较大的一件物品应取走的数量 sum[0]=sum[1]#从备份恢复 sum[0] = sum[0] + t#此时为真正的取走数量 num = list_c[i]*v + num#总价值 list_z[k][2] = 1#取走的标记print u'能带走的糖果的最大价值为:',num 实现的效果图(此处用两组数据进行测试)：第一组数据： 第二组数据：]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现的杨辉三角]]></title>
    <url>%2F171222%2F</url>
    <content type="text"><![CDATA[某日，闲来无事做，就尝试着用Python实现了下杨辉三角，以下使用Python2 实现的杨辉三角 123456789101112131415161718192021222324252627282930def triangel(): print ' '*(20*3)+str(1) #定义起始两行 print ' '*(19*3)+str(1)+' '*5+str(1) for i in range(3,21): if i ==3: L = [1,1] #初始化第二行 L1 = [] for j in range(2,i): z = L[i-j-1]+L[i-j] # 通过上一行构建下一层数据 L1.append(z) # 将数据添加到一个空列表中 L = [1] # 再次对L初始化 L.extend(L1) # 将两个列表合并 L.append(1) # 在L列表中添加最后一个数据“1” # 以下内容为杨辉三角的打印 t = ' '*((21-i)*3)+str(1) # 每次循环进行初始化每列的第一个数据1 for h in range(1,len(L)): # 以下为构建每列的除一个数据外的其他数据， if L[h]&lt;10: # 如果数据小于10，就是其前面5个空格，如果 t = t + ' '*5+str(L[h]) #数据小于100，就减少一个空格，依次类推， elif L[h] &lt;100: # 直至剩余一个空格，用于分辨相邻的数据 t = t+' '*4+str(L[h]) elif L[h] &lt; 1000: t = t + ' '*3+str(L[h]) elif L[h] &lt; 10000: t = t + ' '*2+str(L[h]) elif L[h] &lt; 100000: t = t + ' '*1+str(L[h]) print tif __name__ == "__main__": triangel()]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用chromedriver实现豆瓣网页的全网页截图]]></title>
    <url>%2F190108%2F</url>
    <content type="text"><![CDATA[最近由于工作需要，需要对部分网站进行全文截屏。在网上搜了很久没有搜出好的方法，而且在新版的selenium中已经不在支持PhantomJS了，所以全文截取变得有点棘手。 此处给出一个简单的方法，以20行代码实现selenium+chromedriver+python实现豆瓣的全文截取。 123456789101112131415161718192021from selenium import webdriveroptions = webdriver.ChromeOptions()options.add_argument('--headless')options.add_argument('--dns-prefetch-disable')options.add_argument('--no-referrers')options.add_argument('--disable-gpu')options.add_argument('--disable-audio')options.add_argument('--no-sandbox')options.add_argument('--ignore-certificate-errors')options.add_argument('--allow-insecure-localhost')driver = webdriver.Chrome(options=options)driver.get('http://www.douban.com')width = driver.execute_script( "return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);")height = driver.execute_script( "return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);")driver.set_window_size(width + 100, height + 100)driver.save_screenshot('douban.png')driver.close()]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>Chromedriver</tag>
        <tag>全页面截屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoEngine所使用的操作符]]></title>
    <url>%2F171220%2F</url>
    <content type="text"><![CDATA[什么是MongoEngine？ MongoEngine是基于Python的对象系统设计的MongoDB专用的ORM框架。与SQLAlchemy不同的是，MongoEngine会自动生成一个唯一的标识，用ID属性表示。当然MongoEngine与SQLAlchemy还有很对不同的地方，比如字段类型等。 MongoEngine所支持的部分操作符 操作符的表示形式为:加在关键字后面使用”+操作符”(此处是两个” _ “),例如：publish_datagt ne：不等于 lt：小于 lte：小于或等于 gt：大于 gte：大于或等于 not：对一个操作符取否，例如publish_data__not__gt in：值在列表中 nin：值不在列表中 mod：值%a==b,a和b用(a,b)的方式传递 all：列表中的所有值都在该字段中 size：列表的大小 existes：在该字段中存在这个值 检测字符串的部分操作符 exact：字符串相等 iexact：字符串相等（大小写不敏感） contains：字符串包含该值 icontains：字符串包含该值（大小写不敏感） startswith：字符串以该值开始 istartswith：字符串以该值开始（大小写不敏感） endswith：字符串以该值结束 iendswith：字符串以该值结束（大小写不敏感） 可以对字段值进行修改的操作符 set：设置一个值 unset：删除一个值 inc：将值自增 dec：将值自减 push：把一个值加到列表的末尾 push_all：把几个值加到列表的末尾 pop：移除列表中的第一个或者是最后一个值 pull：移除列表中的值 pull_all：移除列表中的几个值 add_to_set：当且晋档某值不在列表中时，将其添加进列表]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一场说走就走的旅行]]></title>
    <url>%2F180428%2F</url>
    <content type="text"><![CDATA[时光荏苒，岁月如梭，大学里总需要一场说走就走的旅行。或为了心中的她，也或为了自己。 那是一个早晨，我错过了末班车，却没有错过你 人们总说“时间是个好东西，它能让你放下原来放不下的、看淡你原来看不淡的”。或许这就是一种成长吧，建立在原来的痛苦、喜悦之上的成长。在那个时候我很庆幸没有错过你，虽然现在错过了，也没有什么后悔的，因为总需要一场说走就走的旅行。这场旅行无关你我，而是我必须要走的路，或许是我和他人，但我没有想到会是和你。因为这是一场说走就走永不相见的旅行。有些人走着走着就散了说的就是这个道理吧！ 那年我们都很年轻，我们只是两条相交线，很幸运的在某一点相遇了，只是没有想到这个交叉点的停留时间是六年 这场旅行是我一个人走的，因为没有你。路上有很多的美景，但是总觉得少点什么，即使看着这美景，也无心观赏，虽人在观景，但心思却飞向了那个两个月之前。之所以不是现在，是因为现在你让我找不到原谅的理由，也不可能会再相遇。因为我不想再步入那座让我伤心的城市，让我伤心欲绝的城市。这场旅行是我一个人走的，因为花开了。坐在火车窗前观望着窗外的景色，发现窗外遍野的油菜花开了，开的很美、很鲜艳，让人赏心悦目的那种美。不过可惜的是火车并没有因此而停足，而是萧萧而过，窗前的我却开始回忆那种遍野油菜花的美。这场旅行是我一个人走的，因为我不得不一个人走。这场说走就走的旅行是场艰辛的旅行，但是这场旅行也使我有了新的理解，并不是所有都是我想怎么就怎么的，现实不会因为我而改变，但是我却会因为这个现实而改变。或许这就是我场旅行的意义吧。 月台中总有太多的不舍，但终究还是不得不放开 这场旅行中我见了很多新的事物。在原来没有时间去开始这场说走就走的旅行之前，我的世界是狭小的，之后我的世界是广阔的。一场忐忑的旅行，只是没有太多的如果，只有唯一的结果。在这场旅行中虽然是艰辛的，收获也算是有的，但是也有疲惫，疲惫的是在这场旅行开始之前的忐忑，收获的是我彻底可以好好看看这个世界了。或许当我再次看到那片油菜田时，能够认真欣赏，好好珍惜这短瞬即逝的美。纸短情长又如何，回忆终究只是回忆，生活还是要继续的。 旅行结束后，我有了很多的时间去看这个世界了。 也许会在某个美丽的地方再次相遇，也许会永不相遇。太多的放不下终究还是放下了。繁华的世界，流逝的美，这场旅行归来后，我变回了原来的自己，只是多了旅行路途中的辛苦和收获。 后记 “好久不见！” “好久不见！”]]></content>
      <categories>
        <category>往事回廊</category>
      </categories>
      <tags>
        <tag>心灵洗涤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岁月静好]]></title>
    <url>%2F180625%2F</url>
    <content type="text"><![CDATA[开始 故事的开始都很美好 2015年9月2号，我来到了这所大学，虽然这所大学并不是很好的大学，但是这所大学却给了我很多记忆。初入大学，总有太多的新鲜感，逛逛走走，时间总会匆匆而过。记得正式上课的第一天跑错了教室，不是我一人，而是我们整个班，现在想起来都很搞笑。在那一年里，我有着自己的梦想，我期盼着自己的未来，因为我相信自己会过的更好。 悄悄 窗外的景色依旧燥热，有你时如此，无你时也是如此。 我们有些时候总是悄悄的来，然后再悄悄的走开。人生中有很多的聚散，最后不过是风轻云淡。曾经我很爱很爱一个女孩，异地很痛苦，时刻想着她，后来也放下了。有时候人生啊，真的是悄悄的来，悄悄的走。大学四年里，我爱过就好，现在我已经习惯了一个人生活，回忆里和朋友坐在喧闹街市的路边摊，几瓶啤酒，一点小菜。聊起彼此曾经失败的感情，都在岁月变迁里逐渐释怀。胸膛上固守的温度总是会被南来北往的季风吹散，那些念念不忘的名字最后也被后来者取代。记住当时的日色，也未必能与你岁岁相守，彼此停留。 那一年 记忆它总是慢慢的累积在我心中无法抹去 那一年，我认识了你，一句半开玩笑的话，我们在一起了。时至今日，我依然记得当初说的那句玩笑话“要不你做我女朋友吧”，没错，就是这句，然后我们就在一起了，我开心的像个八百斤的胖子一样。之后的我做什么事都会为你想着，爱着你，宠着你，陪着你。只是后来 。。。 只是后来我们走散了。高中的生活中，你是我最美好的回忆，朋友羡慕着你我的感情，而我也认为我们会走到一起。那一年，《漂洋过海来看你》还很火，你对我说“我多想去见你”，因为那年我转到了另一所学校，在那所学校中我过着没有你的生活，殊不知我也很想见你，不善言表的我，不会更好的用语言来表达我对你的爱，而我却选择了为你默默付出。 也许，也许 如果当初没有如果，现在的结局会不会不一样 高考过后，我们去了两所不一样的学校，准确来说是我去了一所离你800多公里外的一所本科学校，而你却选择去了一所专科学校。也许这就注定了之后的结局吧。价值观不同，有时候很难走到一起。那时我们并没分开，而我也只在放假的时候才有空去找你，陪着你。繁忙的学业，时刻都会落后的技术，让我选择了我要给你更好的生活，而你选择的是要我时刻陪伴。大学上课时，手机成为了我们两个唯一交流的桥梁。整日看着手机，每当手机亮了我就知道是你给我发消息。时光蹉跎，岁月静好，三年里我们就是这样过去了，手机、放假后的陪伴。渐渐的我们都变了，17年，你去了你们那里做了一名幼教，你实习之前你问我“以后你养得起我吗”，我沉默了，是啊，我当时的能力能养你吗，我也问我自己，技术那么渣，我怎么去养你。我想了许久，我说“我养你”，后来我变了，变得想要为你我的生活做拼搏。我用实际行动做证明，但是我们却渐渐走散了，我想要给你我所拥有的最好的。接触的不同，价值观也就渐渐的改变了。 后来的我们 美好的爱情大都相似，而不幸的爱情最后都成了故事，如果当时你没走，后来的我们会不会不一样? ——《后来的我们》 后来，我们走散了。分手后的某一天，我突然知道你订了婚，要和别人去结婚了，我突然间觉得有我的世界都坍塌了。虽然我们分手了，我只是我没有想到你会选择那么早结婚。当我知道后的两天中，我彻夜未眠，听了两晚的《体面》。那天是过年后，朋友来找我喝酒，我大醉，醉的不省人事。虽然是醉的不省人事，但是我却记得关于你的话，我说“我想XXX”。那场感情上的坍塌，让我颓废了一星期，一星期之后，我选择了放下，彻彻底底的放下，手机和电脑里都删了关于你的一切。 如今 再见，曾经最爱的她。 如今的我初入社会，离开了有太多记忆的学校。我为了自己的生活做着拼搏，不再是为了我们。]]></content>
      <categories>
        <category>往事回廊</category>
      </categories>
      <tags>
        <tag>Miss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩命追一姑娘]]></title>
    <url>%2F180623%2F</url>
    <content type="text"><![CDATA[玩命的追一姑娘和朋友们聚会，大家决定玩一个游戏。找一个主题，然后讲一段自己的真实经历，看看谁的经历最有起承转合，最催泪，最奇葩，或者最让人无语凝噎，想抄家伙。最后我们选定了一个主题——你有没有玩命爱一个姑娘。这个问题抛出来的时候，大家都沉默了，纷纷在记忆中寻找那一段为了姑娘、为了爱情玩命的激情岁月。在座的男士们，有的已经结婚，有的有了女朋友，有的还是一如既往的单身狗。在大家都沉默的片刻，四张点了根烟，说：“我的故事都到了嗓子眼了，我先说吧。”我笑而不语，等着四张的下文。 四张并没有四十岁。我们二十来岁认识的时候，大家就管他叫四张了。当时，我们都在山东上大学。四张有个青梅竹马的女朋友叫何玉。据四张说，自己和何玉从小穿开裆裤长大，一块啃过锅里的大腿骨，一块光着屁股洗过澡，更神奇的是，两个人生日只差两天，性格互补，血型一致，简直就是上天早就设定好的一对。四张说，在我还不知道男孩和女孩在一起可以生小孩的时候，我就想跟何玉生小孩了。两个人从小在一起过过家家，玩过给对方检查身体的游戏，不论见到谁的父母都可以直接叫爸妈。四张跟何玉从小学到高中一直在一起，两个人一起经历了第二性征发育，长出喉结，胸脯耸起来，梦遗，初潮，青春期的各种烦躁，在别人都早恋的时候，两个人还是单纯得像是初生婴儿。高中时代，何玉出过一次意外，失血过多。四张不由分说地给何玉输了血。四张说，看着我的血通过血管流进何玉的身体里，我就感觉我和何玉血脉相通了。就好像，就好像我把我的基因输送到何玉身体里一样。跟做爱的感觉一模一样，有战栗，有晕眩，还有高潮。真的，不骗人。 最终，两个人去了山东两所相邻的大学，隔着一百八十公里。上大学是两个人这么多年来第一次分开，四张说，我就好像经历了一次连体婴儿分离手术，而何玉就是我的幻肢，我总觉得一转头就能看见她，可是真转过头，又发现她不在了。 真正的变故发生在一年后的情人节前夜。四张接到了何玉的一通电话，电话里，何玉不无娇羞地说，四张，四张，有个男孩子跟我表白哎，你说我该不该答应他啊？四张傻了，在四张听起来，这仿佛就是在问，老公老公，有个男孩子要跟我睡觉哎，你说我该不该答应他？四张疯了，跳起来，念叨着，哎呀，我擦，我擦，我擦。四张外套都没穿，直接冲出宿舍，抄起自己的自行车，蹬上车就往外狂奔。夜色中的马路上，一个只穿着毛衣的缺货发狂地蹬着自行车，正在赶往一百八十公里之外的城市，问题是他要去干嘛呢？四张说，当时我自己也不知道我也去干嘛，也许是去灭口。 四张发狂地蹬了一整夜自行车，从毛衣到内裤都湿透了，整个人冒着热气，像是一个瓦特时代的蒸汽机。到了情人节当天中午，四张终于赶到了何玉的宿舍，跳下自行车的时候，四张差点瘫在地上。多年以后，四张回忆起来的时候，恨恨地说了一句英文：“I cannot feel my legs” 何玉从女生宿舍楼下来的时候，四张正用一种诡异的外八字站着，穿着毛衣，瑟缩着，像是刚刚从戒备最森严的监狱里越狱而出。何玉惊得差点背过气去，你怎么来了？你外套呢？何玉不等四张说话，冲回去，不一会儿，拿着一件女式的粉色及膝羽绒服跑出来，不由分说地套在了四张身上。四张继续用外八字的姿势站着，穿着粉色的女式及膝羽绒服，好不容易憋出一句话，你答应了？何玉一愣，什么？四张几乎都带了哭腔，你答应和追你的那个男人好了？何玉哭笑不得，我……我还没有。四张疯了，那你是准备答应了？何玉沉默了一会儿，娇羞上脸，我不知道。哎，不过我问你，男生追求女生的时候，是不是脑子里都想着那个啊？四张一下子这句话打得痛彻心扉。时隔多年，四张回忆起那个时刻，还是痛得弯下了腰，恨不得立刻倒在地上舔马路。 当天晚上，何玉带着四张到学校餐厅吃了饺子，把四张安排到男生宿舍睡一晚。四张送何玉回女生宿舍的时候，那个追求何玉的男生抱着一束花等在了宿舍楼底下。男生看到何玉身旁穿着粉色女式及膝羽绒服的四张，狐疑地往后退了两步。何玉不好意思地对四张说，我过去跟他说两句。四张说不出话，就看着何玉跑向那个男生，两个人叽里咕噜地不知道在说什么，四张恨自己为什么不好好学学唇语。就在四张忍不住要冲过去的时候，何玉接过了男生递给她的那束花，对着男生娇羞地笑笑。四张听见自己心碎的声音，不是咔嚓，也不是吧唧，也不是轰隆，而是何玉的笑声，呵呵。四张男性的尊严终于复苏，他转身就跑，只留下何玉在他身后喊，你去哪啊？夜色中的马路上，一个穿着女式及膝羽绒服的倒霉缺货，拼命地瞪着自行车奔驰在马路上。四张形容说，那时候的心痛就像是，我的内脏全长在了外面，每走一步，都被粗糙的柏油马路摩擦。 四张无法想象，自己青梅竹马了二十年的女孩，在情人节的夜晚，当着自己的面，答应了另一个不知道哪冒出来的男人的求爱。四张觉得这个世界不会好了。我们帮四张分析，也许是因为，熟悉的地方没有风景，熟悉的男人没有小鸡鸡吧。四张哭着骂了一句，操你们大爷。 大学里剩下的时光，四张没有谈恋爱，转而对各种社团活动产生了兴趣。先后参加过什么大学生电路装置比赛，大学生贫困山区十日行，大学生街头公益筹款之类。 毕业之后，何玉拿到一份不错的offer，去了北京，成了北漂的一员。四张就在山东一家运输公司跑货运，开着那种大卡车，一趟车要跑三四天，车上吃，车上睡，夏天就在驾驶室里挂个蚊帐，冬天就浑身贴着暖宝宝，车里放十几把暖瓶。碰上堵车的时候，也能堵个两三天，四张就和同样被困的司机斗地主，打保皇。一次， 四张开着卡车跑长途送一车情趣玩具，路上，突然接到了何玉的电话。何玉在电话里哭着说，四张，四张，我钱包丢了，身份证也没了，我租的房子下水道也堵了，现在正往外冒水，我找不到房东，我不知道该怎么办？四张一听，嘴里念叨着，哎呀，我擦，我擦，我擦。当即猛地掉转车头，临时改了路线，憋着一泡从山东就带着的尿，拉着一车情趣玩具就往北京狂奔，完全忘记了等着发货那批淘宝店店主。 四张的大货车开不进小区，四张就把车停在小区外面的马路上，自己跳下车，憋着那泡尿，冲到了何玉租住的小区砸门。何玉打开门，看着风尘仆仆的四张，呆住了。四张从牙缝里提出一句话，先让我撒个尿。 何玉听着四张水流湍急地打击着马桶，惊魂未定。紧接着，又听见洗手间里，四张吭哧吭哧的声音。半个小时后，四张走出来，洗手间里焕然一新，下水道也疏通了。四张甩下一叠钱，还有一张银行卡，对何玉说，你先用着。何玉刚要感谢，四张的手机急促的响起，货运公司老板在电话里狂吼，你他妈去哪了？四张一下子急了，嘴里念叨着，哎呀，我擦，我擦，我擦。急忙冲出去，何玉在身后喊，你倒是吃了饭再走啊。四张跑到小区外面，发现两个交警，面对着大货车，不知所措。大货车的吨位，交警的拖车是拖不走的。四张硬着头皮，跑过去，和交警套近乎，说，我老婆生孩子，您行行好。四张认栽交了罚款，又开着货车，拉着一车情趣玩具，在高速公路上狂奔。 四张任劳任怨，勤勤恳恳，攒了钱，自己买了一辆卡车，继续跑着长途，送过各种各样稀奇古怪的货物。他最爱看的电影是《玩命快递》，四张说，这演的就他妈是我啊。我有一次大半夜的，就在一条黑压压的马路上，遇到拦路抢劫的。他们弄了一颗树横在马路中间，我一看不好，猛踩油门，飞驰而过。开除十公里之后，才发现两个轮胎都漏气了。 四张再一次跑北京的时候，在北京留了一天。何玉请四张吃饭。何玉看起来有些奇怪，说话吞吞吐吐。四张不耐烦，有事你就直说，跟我还用得着客气？何玉说，我男朋友做生意，需要一笔钱周转，否则他过不了这个坎。四张一愣，你什么时候交的男朋友？我怎么不知道？何玉有些惭愧，我不想跟你说，我怕说了你难受。四张沉默。何玉说，他借了高利贷。四张点了根烟，问，缺多少钱。何玉鼓足勇气，说，十万。四张抽了两口烟，给我五天，五天之后，我打你银行卡上。四张说着就起身走了，留下何玉愣在原地。 回到山东，四张把卡车卖了，加上自己的积蓄，凑了十万块给何玉。我们都骂他，你脑残了？你不想想，万一何玉那个什么男朋友是个骗子呢？四张无所谓的笑笑，我感觉，那男的百分百是骗子，好男人就是他妈再难，也不会向自己的女人开口要钱。我们都惊呆了，你丫知道还借给她？四张说，她要的东西，我没法拒绝。再说，让她上上课也好，她哪都好，就是太单纯。我们再一次惊呆，她单纯？我看啊，是你傻逼。四张切了一声，大智若愚，聪明还是傻逼，得分事儿。 卖了卡车之后，四张又回到了原来的运输公司，继续打工。一样勤勤恳恳，任劳任怨。两个月后，何玉打电话给四张，哭着说，她男朋友不见了，电话也不接，他是个骗子。我对不起你。四张说，不就十万块钱吗？有什么大不了的。花十万块，让你长长记性，值了。何玉在电话里泣不成声。 四张最爱跑的一条线，就是从山东到北京，他说，总觉得何玉在哪，哪立马就不一样了。就算何玉在撒哈拉，撒哈拉也能凭空生出喷泉来。就算何玉在索马里，索马里就立马变成天上人间。何玉却消失了一段时间，再也没有联系四张，不知道是不是因为觉得自己就是个扫把星，总是拖累四张，因此故意远离四张的生活。 又到了冬天。四张依旧跑着长途，这次他拉着一车泡面跑北京，天寒地冻，高速公路上的积雪刚刚撒过盐，几乎都融化了，但是风很大。四张顺风撒尿的时候，尿柱射到了几百米外的广告牌上。四张过了收费站口，猛地踩了刹车，他看见一个熟悉的身影，站在一望无际的高速公路隔离带旁边，冻得瑟瑟发抖，是何玉。四张头发都炸起来了，他的车堵在高速公路入口，自己跳下去，几乎是飞到何玉面前，一把抱住何玉。何玉整个人冻得就跟个冰美人一样，四张抱着何玉的时候打了个冷战，四张又生气又心疼，你他妈在这干嘛？何玉泣不成声，我在这等了你三天了。晚上就在收费站里睡。我算错了时间，可我又不敢走，怕错过你。四张疯了，你不会打个电话吗？何玉说，我总是给你打电话，打电话给你都没好事，这一次我想见你。四张紧紧地抱住何玉，直到高速公路路口堵成一排的车集体狂摁喇叭。 四张开着大货车，行驶在冰雪皑皑的高速公路上。何玉坐在副驾驶，身上裹着四张的军大衣，正在吃着一碗热气腾腾的泡面。何玉吃完泡面，掏出两万块钱给四张。四张生气了，你这是干什么？何玉说，这是我这段时间攒的，还欠你八万，以后我就跟着你跑长途，给你打工，给你洗衣服，给你做饭。四张傻了，你疯了，跑长途这是女人干的活吗？何玉恨铁不成钢，从小到大，你怎么总是抓不到我的重点？我的重点在后半句，给你洗衣服，给你做饭！四张愣愣地看着何玉，傻了。何玉双颊都冻伤了，泛着红光，认真地看着四张。大卡车远远地往前飞奔。 今年，四张又买了一辆卡车，取了个名字，叫“何玉号”。被同行取笑，你以为你开的是驱逐舰吗？四张说，我开的就是驱逐舰，只属于我和我老婆的驱逐舰，一切坏人坏事统统退避。 四张讲完了自己的故事，大家忍不住给她鼓掌。四张憨笑，其实这也不算玩命爱一个姑娘，离着玩命还早呢。我只是觉得，既然爱了，就用点力，用点力总不会是坏事。这个时候，一个女孩大着肚子走过来，走到四张身边。四张吓坏了，你怎么来了？女孩很娇羞，开玩笑似的，我想你了啊。我们都愣住。四张有些尴尬，跟大家介绍，这是我老婆，何玉。我们都站起来，一起喊，嫂子好。何玉被眼前的阵势吓了一跳，你们好，你们好，有空来家里喝酒。四张笑得很欠揍，明目张胆秀恩爱。 生命中，有些错过，最后成为了错过。而有些错过，因为两个人的勇敢，又变成了相遇。我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，让爱人就离着自己一个枕头的距离，有时候甚至是负20厘米的距离。男人应该玩命爱一个姑娘。好姑娘也值得被男人玩命去爱。爱情，本来就是勇敢者的游戏。如果你不够勇敢，你很快就会出局。如果你够勇敢，此刻转个身，就能抱住你所爱的人吧。]]></content>
      <categories>
        <category>短文</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>付出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那年刚好17岁]]></title>
    <url>%2F230128515%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>往事回廊</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>回忆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进制转换]]></title>
    <url>%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Python中实现的进制间的转换 在python中可以使用Python的内置函数进行进制间的转换。 bin()：其他进制转二进制 oct()：其他进制转八进制 int()：其他进制转十进制 hex()：其他进制转十六进制 二进制、八进制、十六进制的形式 二进制：以“0b”开头，如：0b111为十进制的7 八进制：以“0”开头，如：026为十进制的22 十六进制：以“0x”开头，如：0x1f为十进制的31 二进制、八进制、十六进制对照表 二进制、八进制、十六进制转十进制使用int()函数，第一个参数是要转换的数字，类型为字符串，第二个参数是该数几进制的数，转化结果为一个十进制的数。123456789二进制转十进制：&gt;&gt;&gt; int('0b1111',2)15八进制转十进制：&gt;&gt;&gt; int('67',8)55十六进制转十进制：&gt;&gt;&gt; int('0x1f',16)31 八进制、十进制、十六进制转二进制使用bin()函数，需要先将八进制、十六进制转换为十进制，然后才能转换为二进制，即八进制/十六进制 —&gt; 十进制 —&gt; 二进制123456789八进制转二进制：&gt;&gt;&gt; bin(int('016',8))'0b1110'十进制转二进制：&gt;&gt;&gt; bin(14)'0b1110'十六进制转二进制：&gt;&gt;&gt; bin(int('0xe',16))'0b1110' 二进制、十进制、十六进制转八进制使用oct()函数可以直接进行进制的转换123456789二进制转八进制：&gt;&gt;&gt; oct(0b1110)'016'十进制转八进制：&gt;&gt;&gt; oct(14)'016'十六进制转八进制：&gt;&gt;&gt; oct(0xe)'016' 二进制、八进制、十进制转十六进制使用hex()函数，需要先将二进制、八进制转换为十进制，然后才能转换为十六进制，即二进制/八进制 —&gt; 十进制 —&gt; 十六进制123456789二进制转十六进制：&gt;&gt;&gt; hex(int('0b1110',2))'0xe'八进制转十六进制：&gt;&gt;&gt; hex(int('016',8))'0xe'十进制转十六进制：&gt;&gt;&gt; hex(14)'0xe']]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>八进制</tag>
        <tag>十六进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python位运算]]></title>
    <url>%2FPython%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[Python中的位运算是程序设计中对位模式或二进制的一元和二元操作。按位运算就是把数字转换为机器语言—以二进制形式表示 Python中的位运算有哪些？在Python中，按位运算符有左移运算符（&lt;&lt;）、右移运算符（&gt;&gt;）、按位与运算（&amp;）、按位或运算（|）、按位取反运算（~）、异或运算符，其中按位取反运算符为单目运算符 按位左移运算符（&lt;&lt;）在机器语言中，任何形式均以二进制的形式进行表示：举例：7&lt;&lt;2二进制为：111 左移两位：11100 最后结果为：2812&gt;&gt;&gt; 7&lt;&lt;228 按位右移运算符（&gt;&gt;）具体的使用形式和左移一样。举例：7&gt;&gt;228&gt;&gt;2二进制：7的二进制为：111，右移两位后为001，结果即为128的二进制为:11100，右移两位后为00111，结果为71234&gt;&gt;&gt; 7&gt;&gt;21&gt;&gt;&gt; 28&gt;&gt;27 由于正数和负数的二进制形式不同，所以此处特别说下以下两个运算。在计算机中，负数的二进制形式是其正数的补码形式，此处不做特别的说明，需要知道的以下给出一个链接. 按位与运算（&amp;）正数和正数的与运算：举例： 7&amp;9二进制：7的二进制为:0111，9的二进制为:1001说明：根据（1&amp;1=1、1&amp;0=0、0&amp;1=0、0&amp;0=0）即相同位置同为1结果即为1，否者为0，由此可见7&amp;9的二进制形式为：0111&amp;1001 == 0001正数与负数的与运算：举例：-7&amp;5二进制：-7：1001，5：0101。结果为1说明：此处你可能要问-7的二进制和9的二进制不是相同吗？答案是不相同，在机器中-7的二进制为：11111111 11111111 11111111 11111001，9的二进制为：00000000 00000000 00000000 00001001。同样根据上文的同为1既为1，所以结果为1。运算最后结果的二进制形式从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。负数与负数的与运算：举例：-5&amp;-8二进制：-5：11111011，-8：11111000结果为-8说明：你可能会很疑惑，此处的结果明明是11111000，结果怎么是-8.原因是-5&amp;-8的二进制形式为：11111011&amp;11111000 == 11111000，从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。123456&gt;&gt;&gt; 7&amp;91&gt;&gt;&gt; -7&amp;51&gt;&gt;&gt; -5&amp;-8-8 按位或运算（|）或运算和与运算十分相似，只是依据的逻辑运算不同，或运算的依据逻辑是相同位置有个为1结果即为1正数与正数的或运算：举例：7|9二进制：7：0111，9：1001说明：根据（1|0=1、1|1=1、0|1=1、0|0=0）可知，7|9的二进制形式为：0111|1001，结果为：15负数与正数的或运算：举例：-7|9二进制：-7：11111001，9：00001001说明：从最左侧的第一个0前的1开始的数，转化为十进制，需要进行的是依次相减运算。负数与负数的或运算：举例：-5|-8二进制：-5：11111011，-8：11111000结果为-5说明：运算最后结果的二进制形式从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。123456&gt;&gt;&gt; 7|915&gt;&gt;&gt; -7|9-7&gt;&gt;&gt; -5|-8-5 按位取反运算符（~）将二进制数+1之后乘以-1,假如x的二进制数是y，x的按位翻转是-(y+1)举例：-3去反后：2二进制：-3：11111101 取反操作：-（11111101+1）==-（11111110）==2 异或运算符（^）二进制对应位相加，不进位。依据逻辑为：（1^1=0、1^0=1、0^1=1、0^0=0）,同样依照，如果两个数中一正一负，则最后的二进制转十进制时依次相减，如果同正同负，则相加正数和正数的异或运算：举例：7^9二进制：7：0111，9：1001说明：7^9的二进制形式为：0111^1001 == 1110，十进制为：14负数和正数的异或运算：举例：-3^4二进制：-3：11111101，4：00000100说明：-3^4的二进制形式为：11111101^00000100 == 11111001,根据说明可以知道结果为-（222-1）=-7负数和负数的异或运算：举例：-7^-9二进制：-7：11111001，-9：11110111说明；-7^-9的二进制形式为：11111001^11110111 == 00001110，根据说明可以知道结果为222+2*2+2=14123456&gt;&gt;&gt; 7^914&gt;&gt;&gt; -3^4-7&gt;&gt;&gt; -7^-914]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hypervisor Drivers]]></title>
    <url>%2Fhypervisor-drivers%2F</url>
    <content type="text"><![CDATA[Drivers ModelsThe libvirt library exposes a guaranteed stable API &amp; ABI which is decoupled from any particular virtualization technology. In addition many of the APIs have associated XML schemata which are considered part of the stable ABI guarantee. Internally, there are multiple of implementations of the public ABI, each targeting a different virtualization technology. Each implementation is referred to as a driver. When obtaining a instance of the virConnect class, the application developer can provide a URI to determine which hypervisor driver is activated.No two virtualization technologies have exactly the same functionality. The libvirt goal is not to restrict applications to a lowest common denominator, since this would result in an unacceptably limited API. Instead libvirt attempts to define a representation of concepts and configuration that is hypervisor agnostic, and adaptable to allow future extensions. Thus, if two hypervisors implement a comparable feature, libvirt provides a uniform control mechanism or configuration format for that feature.If a libvirt driver does not implement a particular API, then it will return a VIR_ERR_NO_SUPPORT error code enabling this to be detected. There is also an API to allow applications to the query certain capabilities of a hypervisor, such as the type of guest ABIs that are supported.Internally a libvirt driver will attempt to utilize whatever management channels are available for the virtualization technology in question. For some drivers this may require libvirt to run directly on the host being managed, talking to a local hypervisor, while others may be able to communicate remotely over an RPC service. For drivers which have no native remote communication capability, libvirt provides a generic secure RPC service. This is discussed in detail later in this chapter. Hypervisor drivers Xen: The open source Xen hypervisor providing paravirtualized and fully virtualized machines. A single system driver runs in the Dom0 host talking directly to a combination of the hypervisor,xenstored and xend. Example local URI scheme xen:///. QEMU: Any open source QEMU based virtualization technology, including KVM. A single privileged system driver runs in the host managing QEMU processes. Each unprivileged user account also has a private instance of the driver. Example privileged URI scheme qemu:///system. Example unprivileged URI scheme qemu:///session UML: The User Mode Linux kernel, a pure paravirtualization technology. A single privileged system driver runs in the host managing UML processes. Each unprivileged user account also has a private instance of the driver. Example privileged URI scheme uml:///system. Example unprivileged URI scheme uml:///session OpenVZ: The OpenVZ container based virtualization technology, using a modified Linux host kernel. A single privileged system driver runs in the host talking to the OpenVZ tools. Example privileged URI scheme openvz:///system LXC: The native Linux container based virtualization technology, available with Linux kernels since 2.6.25. A single privileged system driver runs in the host talking to the kernel. Example privileged URI scheme lxc:/// Remote: Generic secure RPC service talking to a libvirtd daemon. Encryption and authentication using a choice of TLS, x509 certificates, SASL (GSSAPI/Kerberos) and SSH tunneling. URIs follow the scheme of the desired driver, but with a hostname filled in, and a data transport name appended to the URI scheme. Example URI to talk to Xen over a TLS channel xen+tls://somehostname/. Example URI to talk to QEMU over a SASL channel qemu+tcp:///somehost/system Test: A mock driver, providing a virtual in-memory hypervisor covering all the libvirt APIs. Facilities testing of applications using libvirt, by allowing automated tests to run which exercise libvirt APIs without needing to deal with a real hypervisor Example default URI scheme test:///default. Example customized URI scheme test:///path/to/driver/config.xml]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Hypervisor</tag>
        <tag>qemu</tag>
        <tag>xen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机的动、静态迁移]]></title>
    <url>%2Fvmmove%2F</url>
    <content type="text"><![CDATA[动静态迁移的原理静态迁移是指在虚拟机关闭或暂停的情况下，将源宿主机上虚拟机的磁盘文件和配置文件拷贝到目标宿主机上。这种方式需要显式的停止虚拟机运行，对服务可用性要求高的需求不合适。 动态迁移无需拷贝虚拟机配置文件和磁盘文件，但是需要迁移的主机之间有相同的目录结构放置虚拟机磁盘文件，可以通过多种方式实现，本例采用基于共享存储动态迁移，通过NFS来实现。 实验环境 源宿主机：Ubuntu17.10 Server版操作系统，4.10.0-38-generic内核。下文中以“Node1”表示，主机名为Service，IP地址为192.168.200.132，NFS挂载目录/opt。 目标宿主机：Ubuntu17.10 Server版操作系统，4.10.0-38-generic内核。下文中以“Node2”表示，主机名为Service1，IP地址为192.168.200.131，NFS挂载目录/opt。 基于QEMU的动态迁移虚拟机镜像文件为ubuntu16server.img。 基于libvirt的静态迁移测试虚拟机：demo1，IP为192.168.200.132，虚拟镜像文件为ubuntu16.img。 基于libvirt的动态迁移测试虚拟机：demo2，IP为192.168.200.131，虚拟镜像文件为ubuntu16.img。 NFS服务器：Ubuntu17.10 Server版，4.10.0-38-generic内核。IP地址为192.168.200.130，服务目录为/opt/share。 配置步骤NFS服务器的搭建 KVM虚拟机动态迁移无需拷贝虚拟机配置文件和磁盘文件，但是需要迁移的主机之间有相同的目录结构放置虚拟机磁盘文件（本例为“/opt/share”目录），这里的动态迁移是基于共享存储动态迁移，通过NFS来实现，需要QEMU 0.12.2以上版本支持。可以使用以下命令查看安装的QEMU的版本号。1qemu-img –help|grep version 首先在NFS服务器上，下载安装NFS，kernel-server相当于server端,common是client端，使用命令以下命令进行安装NFS:1sudo apt-get install nfs-kernel-server nfs-common -y 配置NFS服务器，将NFS服务器上的“/opt/share”目录设为服务目录。首先使用以下命令创建目录，然后修改创建的目录权限，同时如果不放心是否权限修改了，可以查看下文件夹的权限，修改后为“drwxr-xr-x”123sudo mkdir /opt/share,sudo chmod 777 /opt/sharesudo ll /opt 接下来使用vim修改/etc/exports:文件添加共享目录，在该文件最后添加以下内容即可。/opt/share:表示要设置的共享目录，__:表示允许所有的网段访问，也可以使用具体的IP。rw:表示挂载此目录的客户端对该共享目录具有读写权限。sync:表示资料同步写入内存和硬盘。no_root_squash:表示root用户具有对根目录的完全管理访问权限。no_subtree_check:表示不检查父目录的权限。修改完毕后保存退出。1/opt/share (rw,sync,no_subtree_check,no_root_squash) /etc/exports文件修改后，使用命令然后进行刷新。最后启动NFS服务，命令如下:123sudo exportfs –rsudo /etc/init.d/rpcbind restartsudo /etc/init.d/nfs-kernel-server restart NFS服务启动后，在Node1上使用以下命令查看远程主机的共享目录，可以看到以下斜体内容1234sudo showmount -e 192.168.200.130root@Service:~# sudo showmount -e 192.168.200.130Export list for 192.168.200.130:/opt/share * 分别在Node1和Node2上分别挂载NFS服务器的共享文件夹到本地“/opt”目录中，然后将Node1上的的虚拟磁盘文件ubuntu16server.img（前面实验中制作的ubuntu的镜像文件）拷贝到挂载NFS服务器共享目录的文件夹“/opt”中(我制作好的镜像文件在/root文件夹中)，之后可以看到ubuntu16server.img镜像文件。在节点2上执行同样的操作，但在Node2中不用执行拷贝这一命令。12sudo mount -t nfs 192.168.200.130:/opt/share /opt -o rwsudo cp /root/ubuntu16server.img /opt 挂载拷贝完成后两节点都有相同的虚拟机磁盘文件存储目录 基于QEMU的虚拟机动态迁移 在Node1上使用如下命令启动虚拟机，ubuntu16server.img为前面实验制作的镜像文件，-monitor stdio表示可以进入QEMU监控器，以便接下来执行迁移命令。12qemu-system-x86_64 -hda ubuntu16server.img -m 1024 -smp 1 -vnc :0 -monitor stdio(qemu) 打开VNC界面，连接节点1上的QEMU虚拟机,登陆之后并执行“top”命令,可以看到界面一直在发生改变。 在Node2上使用以下命令启动一个虚拟机，该虚拟机并没有真实启动，只是用于等待接收动态迁移过来的内存内容，使用VNC连接后显示界面状态为黑屏，或者是有一行提示。这里需要注意：在Node2上，NFS挂载目录必须与源主机上保持一致；启动客户机命令也需一致，但是需要增加-incoming 选项。“-incoming tcp:0:6666” 这个参数表示在6666 端口建立一个tcp socket 连接用于接收来自于源宿主机的动态迁移的内容，其中“0”表示允许来自任何主机的连接，“-incoming”表示使QEMU进程进入到迁移监听（migration-listen）模式，而不是真正以命令行中的镜像文件运行客户机。另外，这里是以NFS服务器上的镜像文件作为虚拟机磁盘来启动虚拟机，如果有多个用户同时使用NFS服务器上的镜像文件，请将镜像文件在本地进行派生，使用派生后的镜像文件启动虚拟机，具体方式读者可自行查阅相关资料1qemu-system-x86_64 -hda /opt/ubuntu16server.img -m 1024 -smp 1 -vnc :0 -incoming tcp:0:6666 在Node1源宿主机的qemu monitor 命令行中输入以下命令迁移虚拟机，进入动态迁移的流程，其中“192.168.200.131”是目标宿主机IP，TCP协议和6666端口与目标宿主机上命令行的-incoming 参数保持一致1(qemu) migrate tcp:192.168.200.131:6666 //(qemu)为启动镜像时出现的qemu monitor 在Node1上执行”migrate”命令从开始到执行完成，大约十秒钟（视网络而定），在执行完成后迁移成功。迁移后在Node2上，也就是目标宿主机上，之前处于迁移监听状态的虚拟机开始运行，在该虚拟机中可以查看到，原来在Node1上运行的虚拟机上执行的top命令在迁移后仍在继续在Node2上执行。 至此基于QEMU的虚拟机动态迁移完成 基于Libvirt的虚拟机静态迁移 静态迁移也叫做常规迁移、离线迁移（Offline Migration）。是在虚拟机关机或暂停的情况下，拷贝虚拟机磁盘文件与配置文件从源宿主机到目标宿主机中，实现的从一台物理机到另一台物理机的迁移。因为虚拟机的文件系统建立在虚拟机镜像文件上面，所以在虚拟机关机的情况下，只需要简单的迁移虚拟机镜像和相应的配置文件到另外一台物理主机上即可。如果需要保存虚拟机迁移之前的状态，那么应该在迁移之前将虚拟机暂停，然后拷贝状态至目标宿主机，最后在目标宿主机重建虚拟机状态，恢复执行。这种方式的迁移过程需要显式的停止虚拟机的运行。从用户角度看，有明确的一段停机时间，虚拟机上的服务不可用。这种迁移方式简单易行，适用于对服务可用性要求不严格的场合。 为网络添加br0网桥12345sudo brctl addbr br0sudo brctl addif br0 ens33sudo brctl stp br0 onsudo ifconfig ens33 0sudo dhclient br0 在Node1上进行操作，首先确定demo虚拟机状态为“shut off”,如果不是可以执行“destroy ”进行关闭1sudo virsh list –all 准备迁移demo虚拟机，查看demo虚拟机的磁盘文件1virsh domblklist 导出虚拟机配置文件demo.xml、ubuntu16.img,将其发送到Node2中与Node1中文件对应的文件夹（demo.xml文件在文章结尾会给出代码）1sudo scp /root/demo.xml /root/ubuntu16.img 192.168.200.131:/root 之后开始在目标宿主机Node2上进行虚拟机的配置和启动。 使用virsh的子命令define定义并注册demo虚拟机1sudo virsh define /root/demo.xml 启动迁移后的demo虚拟机,通过VNC查看,VNC端口查看 1sudo virsh vncdisplay 然后通过VNC查看是否可以登陆和其他操作 基于Libvirt的虚拟机动态迁移 此处我说明下，这种迁移虽然为基于Libvirt的动态迁移，但是其迁移的只是虚拟机的状态而不是虚拟机的状态和文件，这一点我再次特别说明。 将Node1上的“ubuntu16.img”发送到Node2对应的文件夹,此时的demo状态为“shut off”，发送后启动demo虚拟机 1sudo scp /root/ubuntu16.img 192.168.200.131:/root 查看Node1上虚拟机状态，demo虚拟机保证处于“runing”（如果demo处于“shut off”，将其启动运行“sudo virsh start demo”） 1sudo virsh list –all 查看Node2上虚拟机状态，确保无虚拟机运行，命令如上 通过VNC连接登陆，并执行“top”命令 在Node1上执行“virsh migrate”迁移命令，虚拟机demo在迁移出去的过程中，状态有从“running”到“shut off”的一个改变。–verbose 指迁移demo虚拟机，192.168.200.131为节点2的IP地址，使用tcp协议连接，–unsafe参数表示跳过安全检测, /system为以root身份进行状态迁移,qemu+ssh表示为通过ssh通道连接到远程节点的system实例，具有最大权限来管理远程节点上的虚拟机资源 1sudo virsh migrate –live –verbose demo qemu+ssh://192.168.200.131/system tcp://192.168.200.131 –unsafe 在Node2上,查看虚拟机demo虚拟机状态为“runing” 1sudo virsh list –all 在迁移过程中，可以通过另外一台客户机一直ping虚拟机demo，查看demo迁移过程中的可连接性。实际上迁移过程除了偶尔有几个包的中断，基本上没有太大影响 此时虽然demo虚拟机已经在Node2上启动了，但是Node2上还没有demo虚拟机的配置文件。这时需要创建配置文件并定义该虚拟机，可以通过迁移过来的虚拟机内存状态创建虚拟机配置文件，然后通过xml配置文件定义虚拟机。 12sudo virsh dumpxml demo &gt; /etc/libvirt/qemu/demo1.xml //之所以命名为demo1.xml是因为，在libvirt静态迁移过程中已经有个demo.xml文件，虽然不在同一个文件夹，为了避免搞混。sudo virsh define /etc/libvirt/qemu/demo1.xml 通过VNC连接查看，VNC端口号查询。 1sudo virsh vncdisplay demo 在通过VNC连接上后发现迁移前的“top”命令依然在执行 至此，demo虚拟机迁移完成。 demo.xml文件中的内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!--WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BEOVERWRITTEN AND LOST. Changes to this xml configuration should be made using: virsh edit demoor other application using the libvirt API.--&gt;&lt;domain type='kvm'&gt; &lt;name&gt;demo&lt;/name&gt; &lt;uuid&gt;782ca9b9-8403-4fcd-979e-e4f038aaeb15&lt;/uuid&gt; &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt; &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt; &lt;vcpu placement='static'&gt;1&lt;/vcpu&gt; &lt;os&gt; &lt;type arch='x86_64' machine='pc-i440fx-trusty'&gt;hvm&lt;/type&gt; &lt;boot dev='cdrom'/&gt; &lt;boot dev='hd'/&gt; &lt;/os&gt; &lt;features&gt; &lt;acpi/&gt; &lt;apic/&gt; &lt;pae/&gt; &lt;/features&gt; &lt;clock offset='localtime'/&gt; &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt; &lt;on_reboot&gt;restart&lt;/on_reboot&gt; &lt;on_crash&gt;destroy&lt;/on_crash&gt; &lt;devices&gt; &lt;emulator&gt;/usr/bin/kvm&lt;/emulator&gt; &lt;disk type='file' device='disk'&gt; &lt;driver name='qemu' type='qcow2'/&gt; &lt;source file='/home/ubuntu16.img'/&gt; &lt;target dev='hda' bus='ide'/&gt; &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt; &lt;/disk&gt; &lt;controller type='usb' index='0'&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/&gt; &lt;/controller&gt; &lt;controller type='pci' index='0' model='pci-root'/&gt; &lt;controller type='ide' index='0'&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/&gt; &lt;/controller&gt; &lt;interface type='bridge'&gt; &lt;mac address='52:54:00:c0:a2:8a'/&gt; &lt;source bridge='br0'/&gt; &lt;model type='rtl8139'/&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt; &lt;/interface&gt; &lt;input type='tablet' bus='usb'/&gt; &lt;input type='mouse' bus='ps2'/&gt; &lt;input type='keyboard' bus='ps2'/&gt; &lt;graphics type='vnc' port='-1' autoport='yes' listen='0.0.0.0' keymap='en-us'/&gt; &lt;video&gt; &lt;model type='cirrus' vram='9216' heads='1'/&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/&gt; &lt;/video&gt; &lt;memballoon model='virtio'&gt; &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt; &lt;/memballoon&gt; &lt;/devices&gt;&lt;/domain&gt;]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>虚拟机迁移</tag>
        <tag>NFS</tag>
        <tag>动态迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tempfile模块的用法]]></title>
    <url>%2Ftempfile%2F</url>
    <content type="text"><![CDATA[tempfile模块，用来对临时数据进行操作 tempfile 临时文件(夹)操作tempfile.mkstemp([suffix=”[, prefix=’tmp’[, dir=None[, text=False]]]])mkstemp方法用于创建一个临时文件。该方法仅仅用于创建临时文件，调用tempfile.mkstemp函数后，返回包含两个元素的元组，第一个元素指示操作该临时文件的安全级别，第二个元素指示该临时文件的路径。参数suffix和prefix分别表示临时文件名称的后缀和前缀；dir指定了临时文件所在的目录，如果没有指定目录，将根据系统环境变量TMPDIR, TEMP或者TMP的设置来保存临时文件；参数text指定了是否以文本的形式来操作文件，默认为False，表示以二进制的形式来操作文件。 tempfile.mkdtemp([suffix=”[, prefix=’tmp’[, dir=None]]])该函数用于创建一个临时文件夹。参数的意思与tempfile.mkdtemp一样。它返回临时文件夹的绝对路径。 tempfile.mktemp([suffix=”[, prefix=’tmp’[, dir=None]]])mktemp用于返回一个临时文件的路径，但并不创建该临时文件。 tempfile.tempdir该属性用于指定创建的临时文件（夹）所在的默认文件夹。如果没有设置该属性或者将其设为None，Python将返回以下环境变量TMPDIR, TEMP, TEMP指定的目录，如果没有定义这些环境变量，临时文件将被创建在当前工作目录。 tempfile.gettempdir()gettempdir()则用于返回保存临时文件的文件夹路径。 tempfile.TemporaryFile([mode=’w+b’[, bufsize=-1[, suffix=”[, prefix=’tmp’[, dir=None]]]]])该函数返回一个类文件对象(file-like)用于临时数据保存（实际上对应磁盘上的一个临时文件）。当文件对象被close或者被del的时候，临时文件将从磁盘上删除。mode、bufsize参数的单方与open()函数一样；suffix和prefix指定了临时文件名的后缀和前缀；dir用于设置临时文件默认的保存路径。返回的类文件对象有一个file属性，它指向真正操作的底层的file对象。 tempfile.NamedTemporaryFile([mode=’w+b’[, bufsize=-1[, suffix=”[, prefix=’tmp’[, dir=None[, delete=True]]]]]])tempfile.NamedTemporaryFile函数的行为与tempfile.TemporaryFile类似，只不过它多了一个delete参数，用于指定类文件对象close或者被del之后，是否也一同删除磁盘上的临时文件（当delete = True的时候，行为与TemporaryFile一样）。 tempfile.SpooledTemporaryFile([max_size=0[, mode=’w+b’[, bufsize=-1[, suffix=”[, prefix=’tmp’[, dir=None]]]]]])tempfile.SpooledTemporaryFile函数的行为与tempfile.TemporaryFile类似。不同的是向类文件对象写数据的时候，数据长度只有到达参数max_size指定大小时，或者调用类文件对象的fileno()方法，数据才会真正写入到磁盘的临时文件中。]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>tempfile</tag>
        <tag>临时文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSPath的用法]]></title>
    <url>%2FOS-Path%2F</url>
    <content type="text"><![CDATA[OS.path模块中的部分函数的介绍 os.path.abspath(path) #返回绝对路径 os.path.basename(path) #返回文件名 os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。 os.path.dirname(path) #返回文件路径 os.path.exists(path) #路径存在则返回True,路径损坏返回False os.path.lexists #路径存在则返回True,路径损坏也返回True os.path.expanduser(path) #把path中包含的”~”和”~user”转换成用户目录 os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}” os.path.getatime(path) #返回最后一次进入此path的时间。 os.path.getmtime(path) #返回在此path下最后一次修改的时间。 os.path.getctime(path) #返回path的大小 os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误 os.path.isabs(path) #判断是否为绝对路径 os.path.isfile(path) #判断路径是否为文件 os.path.isdir(path) #判断路径是否为目录 os.path.islink(path) #判断路径是否为链接 os.path.ismount(path) #判断路径是否为挂载点（） os.path.join(path1[, path2[, …]]) #把目录和文件名合成一个路径 os.path.normcase(path) #转换path的大小写和斜杠 os.path.normpath(path) #规范path字符串形式 os.path.realpath(path) #返回path的真实路径 os.path.relpath(path[, start]) #从start开始计算相对路径 os.path.samefile(path1, path2) #判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件 os.path.split(path) #把路径分割成dirname和basename，返回一个元组 os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组 os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path) #把路径分割为加载点与文件 os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数 os.path.supports_unicode_filenames #设置是否支持unicode路径名]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>os模块</tag>
        <tag>path的用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP Module]]></title>
    <url>%2FFTP-Module%2F</url>
    <content type="text"><![CDATA[ftplib模块的用法 login(user=’’,passwd=’’, acct=’’) 登录到FTP 服务器，所有的参数都是可选的 pwd() 当前工作目录 cwd(path) 把当前工作目录设置为path dir([path[,…[,cb]]) 显示path 目录里的内容，可选的参数cb 是一个回调函数，会被传给retrlines()方法 nlst([path[,…]) 与dir()类似，但返回一个文件名的列表，而不是显示这些文件名 retrlines(cmd [, cb]) 给定FTP 命令（如“RETR filename”），用于下载文本文件。可选的回调函数cb 用于处理文件的每一行 retrbinary(cmd, cb[,bs=8192[, ra]]) 与retrlines()类似，只是这个指令处理二进制文件。回调函数cb 用于处理每一块（块大小默认为8K）下载的数据。 storlines(cmd, f) 给定FTP 命令（如“STOR filename”），以上传文本文件。要给定一个文件对象f storbinary(cmd, f[,bs=8192]) 与storlines()类似，只是这个指令处理二进制文件。要给定一个文件对象f，上传块大小bs 默认为8Kbs=8192]) rename(old, new) 把远程文件old 改名为new delete(path) 删除位于path 的远程文件 mkd(directory) 创建远程目录 此处给出官方给的介绍123456789101112131415161718192021222324Methods defined here:|| init(self, host=’’, user=’’, passwd=’’, acct=’’, keyfile=None, certfile=None, context=None, timeout=, source_address=None)|| auth(self)| Set up secure control connection by using TLS/SSL.|| login(self, user=’’, passwd=’’, acct=’’, secure=True)|| ntransfercmd(self, cmd, rest=None)|| prot_c(self)| Set up clear text data connection.|| prot_p(self)| Set up secure data connection.|| retrbinary(self, cmd, callback, blocksize=8192, rest=None)|| retrlines(self, cmd, callback=None)|| storbinary(self, cmd, fp, blocksize=8192, callback=None, rest=None)|| storlines(self, cmd, fp, callback=None)]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaseServer]]></title>
    <url>%2FBaseServer%2F</url>
    <content type="text"><![CDATA[服务器类型 5种类型：BaseServer，TCPServer，UnixStreamServer，UDPServer，UnixDatagramServer。注意：BaseServer不直接对外服务。 服务器对象 class SocketServer.BaseServer:这是模块中的所有服务器对象的超类。它定义了接口，如下所述，但是大多数的方法不实现，在子类中进行细化。 BaseServer.fileno():返回服务器监听套接字的整数文件描述符。通常用来传递给select.select(), 以允许一个进程监视多个服务器。 BaseServer.handle_request():处理单个请求。处理顺序:get_request(),verify_request(),process_request()。如果用户提供handle()方法抛出异常，将调用服务器的handle_error()方法。如果self.timeout内没有请求收到， 将调用handle_timeout()并返回handle_request()。 BaseServer.serve_forever(poll_interval=0.5):处理请求，直到一个明确的shutdown()请求。每poll_interval秒轮询一次shutdown。忽略self.timeout。如果你需要做周期性的任务，建议放置在其他线程。 BaseServer.shutdown():告诉serve_forever()循环停止并等待其停止。python2.6版本。 BaseServer.address_family::地址家族，比如socket.AF_INET和socket.AF_UNIX。 BaseServer.RequestHandlerClass:用户提供的请求处理类，这个类为每个请求创建实例。 BaseServer.server_address:服务器侦听的地址。格式根据协议家族地址的各不相同，请参阅socket模块的文档。 BaseServer.socketSocket:服务器上侦听传入的请求socket对象的服务器。 服务器类支持下面的类变量 BaseServer.allow_reuse_address：服务器是否允许地址的重用。默认为false ，并且可在子类中更改。 BaseServer.request_queue_size 请求队列的大小如果单个请求需要很长的时间来处理，服务器忙时请求被放置到队列中，最多可以放request_queue_size个。一旦队列已满，来自客户端的请求将得到 “Connection denied”错误。默认值通常为5 ，但可以被子类覆盖。 BaseServer.socket_type：服务器使用的套接字类型;socket.SOCK_STREAM和socket.SOCK_DGRAM等。 BaseServer.timeout：超时时间，以秒为单位，或 None表示没有超时。如果handle_request()在timeout内没有收到请求，将调用handle_timeout()。 下面方法可以被子类重载，它们对服务器对象的外部用户没有影响。 BaseServer.finish_request()：实际处理RequestHandlerClass发起的请求并调用其handle()方法。 常用。 BaseServer.get_request()：接受socket请求，并返回二元组包含要用于与客户端通信的新socket对象，以及客户端的地址。 BaseServer.handle_error(request, client_address)：如果RequestHandlerClass的handle()方法抛出异常时调用。默认操作是打印traceback到标准输出，并继续处理其他请求。 BaseServer.handle_timeout()：超时处理。默认对于forking服务器是收集退出的子进程状态，threading服务器则什么都不做。 BaseServer.process_request(request, client_address) :调用finish_request()创建RequestHandlerClass的实例。如果需要，此功能可以创建新的进程或线程来处理请求,ForkingMixIn和ThreadingMixIn类做到这点。常用。 BaseServer.server_activate()：通过服务器的构造函数来激活服务器。默认的行为只是监听服务器套接字。可重载。 BaseServer.server_bind()：通过服务器的构造函数中调用绑定socket到所需的地址。可重载。 BaseServer.verify_request(request, client_address)：返回一个布尔值，如果该值为True ，则该请求将被处理，反之请求将被拒绝。此功能可以重写来实现对服务器的访问控制。默认的实现始终返回True。client_address可以限定客户端，比如只处理指定ip区间的请求。 常用。 请求处理器处理器接收数据并决定如何操作。它负责在socket层之上实现协议（i.e., HTTP, XML-RPC, or AMQP)，读取数据，处理并写反应。可以重载的方法如下： setup():准备请求处理. 默认什么都不做，StreamRequestHandler中会创建文件类似的对象以读写socket. handle():处理请求。解析传入的请求，处理数据，并发送响应。默认什么都不做。常用变量：self.request，self.client_address，self.server。 finish():环境清理。默认什么都不做，如果setup产生异常，不会执行finish。 通常只需要重载handle,self.request的类型和数据报或流的服务不同。 对于流服务，self.request是socket 对象； 对于数据报服务，self.request是字符串和socket。可以在子类StreamRequestHandler或 DatagramRequestHandler中重载，重写setup()和finish(),并提供self.rfile和self.wfile属性。self.rfile和self.wfile可以读取或写入，以获得请求数据或将数据返回到客户端。]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>base server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>起始篇</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
