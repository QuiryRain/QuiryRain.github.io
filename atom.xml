<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuiryRain的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quiryrain.tk/"/>
  <updated>2019-07-02T09:53:28.236Z</updated>
  <id>http://quiryrain.tk/</id>
  
  <author>
    <name>QuiryRain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程爬虫</title>
    <link href="http://quiryrain.tk/190630/"/>
    <id>http://quiryrain.tk/190630/</id>
    <published>2019-06-30T07:33:40.000Z</published>
    <updated>2019-07-02T09:53:28.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h3><p>多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就好比多线程是火车的每一节车厢，而进程就是火车，车厢离开火车无法启动。多线程的出现是为了提高效率。</p><h3 id="threading模块介绍"><a href="#threading模块介绍" class="headerlink" title="threading模块介绍"></a>threading模块介绍</h3><p>threading模块是python中专门提供用来多线程编程的模块。threading模块中最常用的类是Thread。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;x&#125;</span> 正在写代码"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;x&#125;</span> 正在画图"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=coding)</span><br><span class="line">    t2 = threading.Thread(target=drawing)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure><h4 id="查看线程数"><a href="#查看线程数" class="headerlink" title="查看线程数"></a>查看线程数</h4><p>使用threading.enumerate()函数可以看到当前线程的数量</p><h4 id="查看当前线程的名字"><a href="#查看当前线程的名字" class="headerlink" title="查看当前线程的名字"></a>查看当前线程的名字</h4><p>使用threading.current_thread()函数可以看到当前线程的信息。</p><h4 id="继承自threading-Thread类"><a href="#继承自threading-Thread类" class="headerlink" title="继承自threading.Thread类"></a>继承自threading.Thread类</h4><p>为了让线程代码得到更好的封装，可以使用到threading模块下的Thread类，继承自Thread类后，然后实现run方法，线程代码会自动运行run方法中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodingThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;threading.current_thread()&#125;</span> 正在写代码'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawingThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;threading.current_thread()&#125;</span> 正在画图'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = CodingThread()</span><br><span class="line">    t2 = DrawingThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure><h4 id="多线程共享全局变量的问题"><a href="#多线程共享全局变量的问题" class="headerlink" title="多线程共享全局变量的问题"></a>多线程共享全局变量的问题</h4><p>多线程都是在同一个进程中运行的，因此在进程中的全局变量多有线程都是可共享的。由于线程执行的顺序是无序的，线程如果同时执行，有可能会造成数据错误。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ticket</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    print(<span class="string">f"tickets: <span class="subst">&#123;tickets&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>为了解决以上使用共享全局变量的问题，threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时无法使用，直到当前线程处理完成后，把锁释放，其他线程才能使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ticket</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line">    print(<span class="string">f"tickets: <span class="subst">&#123;tickets&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>_注意_：lock锁加在修改全局变量的位置，如果只是访问全局变脸没有必要加锁。</p><h4 id="Lock生产者和消费者模式"><a href="#Lock生产者和消费者模式" class="headerlink" title="Lock生产者和消费者模式"></a>Lock生产者和消费者模式</h4><p>生产者和消费者模式是多线程开发中经常看到的一种模式。生产者的线程专门用来生产一些数据，然后存放在一个中间变量中。消费者再从这个中间变量中取出数据进行消费。但是因为要使用中间变量，中间变量由于经常是些全局变量，因此在使用的时候需要使用Lock锁来保证数据完整性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gLock = threading.Lock()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= <span class="number">10</span>:</span><br><span class="line">                gLock.release()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元"</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gMoney &gt; money:</span><br><span class="line">                gMoney -= money</span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元"</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> gMoney &gt;= <span class="number">10</span>:</span><br><span class="line">                    gLock.release()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！"</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f"消费者线程<span class="subst">&#123;x&#125;</span>"</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f"生产者线程<span class="subst">&#123;x&#125;</span>"</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="Condition生产者和消费者模式"><a href="#Condition生产者和消费者模式" class="headerlink" title="Condition生产者和消费者模式"></a>Condition生产者和消费者模式</h4><p>Lock中的生产者与消费者模式可以正常运行，但是存在一个问题，在消费者中，总是通过while死循环上锁的方式判断money的多少。由于上锁是一个很消耗CPU资源的行为，因此此方式不是最好的。还有一种更好的方式是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作，还可以提升程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行加锁，也可以在修改完毕后解锁。以下对部分常用函数进行简单介绍：</p><ol><li>acquire：上锁</li><li>release：解锁</li><li>wait：将当前线程处于等待状态，并且释放锁。可以被其他线程使用notify和notify_all函数进行唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li><li>notify：通知某个正在等待的线程，默认是第一个等待的线程。</li><li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gCondition = threading.Condition()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line">gTotalTimes = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                gCondition.release()</span><br><span class="line">                print(<span class="string">f"当前生产者总共生产了<span class="subst">&#123;gTimes&#125;</span>次"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元"</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.notify_all()</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">while</span> gMoney &lt; money:</span><br><span class="line">                <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                    gCondition.release()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！"</span>)</span><br><span class="line">                gCondition.wait()</span><br><span class="line"></span><br><span class="line">            gMoney -= money</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f"消费者线程<span class="subst">&#123;x&#125;</span>"</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f"生产者线程<span class="subst">&#123;x&#125;</span>"</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Queue线程安全队列"><a href="#Queue线程安全队列" class="headerlink" title="Queue线程安全队列"></a>Queue线程安全队列</h3><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你想把一些数据存储到某个队列中，可以使用Python内置的Queue模块。Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列、LIFO(后进先出)队列。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列实现线程间的同步。相关函数：</p><ol><li>初始化Queue(maxsize)：创建一个先进先出的队列</li><li>qsize()：返回队列的大小</li><li>empty()：判断队列是否为空</li><li>full()：判断队列是否满了</li><li>get()：从队列中取最后一个数据</li><li>put()：将一个数据放到队列中</li></ol><h4 id="使用生产者消费者模式多线程下载表情包"><a href="#使用生产者消费者模式多线程下载表情包" class="headerlink" title="使用生产者消费者模式多线程下载表情包"></a>使用生产者消费者模式多线程下载表情包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, page_queue, img_queue, *args, **kwargs)</span>:</span></span><br><span class="line">        super(Producer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            url = self.page_queue.get()</span><br><span class="line">            self.parse_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        response = requests.get(url, headers=self.headers)</span><br><span class="line">        text = response.text</span><br><span class="line">        html = etree.HTML(text)</span><br><span class="line">        imgs = html.xpath(<span class="string">'//a[@class="col-xs-6 col-sm-3"]/img'</span>)</span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">            <span class="keyword">if</span> img.get(<span class="string">'class'</span>) == <span class="string">'gif'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            img_url = img.get(<span class="string">'data-original'</span>)</span><br><span class="line">            suffix = os.path.splitext(img_url)[<span class="number">1</span>].replace(<span class="string">'.null'</span>, <span class="string">'.jpg'</span>)</span><br><span class="line">            alt = img.get(<span class="string">'alt'</span>)</span><br><span class="line">            alt = re.sub(<span class="string">r'[，。？！!?,/\\.]'</span>, <span class="string">''</span>, alt)</span><br><span class="line">            img_name = alt + suffix</span><br><span class="line">            self.img_queue.put((img_url, img_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, page_queue, img_queue, *args, **kwargs)</span>:</span></span><br><span class="line">        super(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.img_queue.empty():</span><br><span class="line">                <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            img = self.img_queue.get(block=<span class="literal">True</span>)</span><br><span class="line">            url, filename = img</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'images'</span>):</span><br><span class="line">                os.makedirs(<span class="string">'images/'</span>)</span><br><span class="line">            result = util.retrieve(url, headers=self.headers, path=<span class="string">'images/'</span>+filename)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;filename&#125;</span> 下载完成!'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;filename&#125;</span> 下载失败！'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    page_queue = Queue(<span class="number">100</span>)</span><br><span class="line">    img_queue = Queue(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        url = <span class="string">f'http://www.doutula.com/photo/list/?page=<span class="subst">&#123;x&#125;</span>'</span></span><br><span class="line">        page_queue.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = Producer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = Consumer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(url, headers=None, path=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(headers, dict):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    opener = request.build_opener()</span><br><span class="line">    opener.addheaders = [result <span class="keyword">for</span> result <span class="keyword">in</span> zip(headers.keys(), headers.values())]</span><br><span class="line">    request.install_opener(opener)</span><br><span class="line">    request.urlretrieve(url, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">urlopen</span><span class="params">(url, headers=None, data=None,origin_req_host=None, unverifiable=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 method=None)</span>:</span></span><br><span class="line">    req = request.Request(url, headers=headers, data=data, origin_req_host=origin_req_host,</span><br><span class="line">                          unverifiable=unverifiable, method=method)</span><br><span class="line">    resp = request.urlopen(req)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><p>Python自带的解释器是CPython。CPython解释器的多线程实际上是一个伪多线程（在多核CPU中，只能利用一核，无法利用多核的优势）。同一时刻只有一个线程执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中便引入了GIL（Global Intepreter Lock），叫做全局解释器锁。因为在CPython解释器的内存管理不是线程安全的，所以还有其他的解释器。</p><ul><li><p>Ipython</p><p>Ipython是基于CPython之上一个交互解释器，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p></li><li><p>PyPy</p><p>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。在PyPy中，同样也是存在GIL锁的。</p></li><li><p>Jython</p><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。不存在GIL锁。</p></li><li><p>IronPython</p><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。不存在GIL锁。</p></li></ul><p>GIL虽然是一个假的多线程，但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;多线程介绍&quot;&gt;&lt;a href=&quot;#多线程介绍&quot; class=&quot;headerlink&quot; title=&quot;多线程介绍&quot;&gt;&lt;/a&gt;多线程介绍&lt;/h3&gt;&lt;p&gt;多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就
      
    
    </summary>
    
      <category term="爬虫" scheme="http://quiryrain.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="多线程" scheme="http://quiryrain.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="threading" scheme="http://quiryrain.tk/tags/threading/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup4库</title>
    <link href="http://quiryrain.tk/190628-1/"/>
    <id>http://quiryrain.tk/190628-1/</id>
    <published>2019-06-28T10:42:52.000Z</published>
    <updated>2019-06-29T09:39:14.675Z</updated>
    
    <content type="html"><![CDATA[<p>和lxml一样，BeautifulSoup也是一个HTML/XML的解析器，主要的功能也是解析和提取HTML/XML数据。</p><p>lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有很大的开销，所以性能要低于lxml。</p><p>BeautifulSoup用来解析HTML比较简单，其API设计的非常人性化，同时BeautifulSoup也支持CSS选择器、Python标准库中的HTML解析器、lxml的XML。</p><p>安装：<code>pip install bs4</code></p><p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><table><thead><tr><th>解析工具</th><th>解析速度</th><th>使用难度</th></tr></thead><tbody><tr><td>BeautifulSoup4</td><td>最慢</td><td>最简单</td></tr><tr><td>lxml</td><td>快</td><td>简单</td></tr><tr><td>正则</td><td>最快</td><td>最难</td></tr></tbody></table><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure><p>BeautifulSoup(markup, features):在使用的时候需要指定解析器，如果未指定，BeautifulSoup使用的Python标准库中的HTML解析器，同时beautifulsoup也支持第三方的解析器如lxml。另一个可供选择的解析器是纯Python实现的html5lib，html5lib的解析方式与浏览器相同。</p><p>安装lxml：<code>pip install lxml</code></p><p>安装html5lib: <code>pip install html5lib</code></p><p>主要解析器的优缺点：</p><p><img src="/userImages/20190629_000.png" alt="解析器"></p><h3 id="四个常用的对象"><a href="#四个常用的对象" class="headerlink" title="四个常用的对象"></a>四个常用的对象</h3><p>BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：</p><ol><li>Tag</li><li>NavigatableString</li><li>BeautifulSoup</li><li>Comment</li></ol><h3 id="操作讲解"><a href="#操作讲解" class="headerlink" title="操作讲解"></a>操作讲解</h3><p>以下内容以4个例子的形式进行讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;div data-v-a6e3291a="" class="correlation-degree"&gt;</span></span><br><span class="line"><span class="string">  &lt;div data-v-a6e3291a="" class="recruit-wrap recruit-margin"&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;TEG15-计费产品web前端开发工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯计费平台基础支付前端架构设计和开发工作； 参与需求评审、架构设计、编码设计和上线运维； 负责用户体验优化，包括但不限于：业务流程、前端展示、性能、安全等。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;PCG19-腾讯视频媒资后台开发工程师&lt;/h4&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;腾讯视频&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯视频媒资中台开发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;TEG15-计费系统前端测试工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责web端/后台系统测试工作，从整个项目角度规划测试方法，达成项目质量目标； 负责web端/后台系统的自动化测试、性能测试，稳定性以及其它专项测试； 负责研究web端/后台系统测试技术，跟进业界测试技术发展，引进先进测试方法并开展二次开发，建立团队质量体系建设，有效提升测试效率&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;32032-资深后台开发工程师（上海）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;IEG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;上海,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;游戏服务器的功能开发和现有系统的持续优化； 负责服务器压力测试和性能优化； 负责服务器外网运营的持续跟进和优化。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;WXG03-搜索自然语言算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责包括新词发现、命名实体识别、查询理解、意图提取、知识图谱、搜索喜好偏向性等相关系统的建设，用以优化微信小程序搜索各产品方向的流量分发，并参与工程实践。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;WXG03-搜索检索算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责微信小程序搜索各个产品方向的检索工作，内容包括页面识别、页面核心数据提取、页面分类、页面评分、词权重、排序等相关工作，并与开发工程师配合进行工程实践。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;23486-证券业务C++后台开发高级工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责证券交易、风控、清算等系统的开发维护，建设证券业务相关的技术基础平台。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;22989-腾讯云数据平台产品中心运营开发&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;CSIG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责腾讯云数据平台产品的设计和研发。 负责云产品数据管理和服务的设计和研发。 负责构建和完善云底层数据的存储和查询，优化数据的质量和监控能力。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;18428-证券业务测试工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;财付通&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责证券类产品的功能、性能、安全、自动化等测试工作，包括终端/H5及后台系统的测试。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a="" class="recruit-list"&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a="" class="recruit-list-link"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a="" class="recruit-title"&gt;30360-后台平台开发（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-tips"&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;深圳总部,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=""&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=""&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a="" class="recruit-text"&gt;负责QQ平台海量用户和数据的基础后台研发工作； 负责AI基础架构系统后台研发工作； 负责推荐系统，大数据分析计算后台研发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a="" class="recruit-collection"&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="icon-collection"&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a="" class="collection-text"&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>获取所有的class属性为“recruit-list”的div标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divs = soup.find_all(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">"recruit-list"</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    print(div)</span><br></pre></td></tr></table></figure></li><li><p>获取第二个class属性为“recruit-list”的div标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div = soup.find_all(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">"recruit-list"</span>&#125;, limit=<span class="number">2</span>)[<span class="number">1</span>]</span><br><span class="line">print(div)</span><br></pre></td></tr></table></figure></li><li><p>获取所有的h4标签中的class属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h4_texts = soup.find_all(<span class="string">'h4'</span>)</span><br><span class="line"><span class="keyword">for</span> h4_text <span class="keyword">in</span> h4_texts:</span><br><span class="line">    print(h4_text[<span class="string">'class'</span>])</span><br></pre></td></tr></table></figure></li><li><p>获取所有的职位信息（纯文本）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aEs = soup.find_all(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><ol><li><p>方法一</p><p>输出的字符串中可能包含了很多空格或空行,使用 <code>.stripped_strings</code> 可以去除多余空白内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    infos = list(aE.stripped_strings)</span><br><span class="line">    print(infos)</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">job = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    h4 = aE.find(<span class="string">'h4'</span>).string</span><br><span class="line">    ps = aE.find_all(<span class="string">'p'</span>)</span><br><span class="line">    spans = ps[<span class="number">0</span>].find_all(<span class="string">'span'</span>)</span><br><span class="line">    span = <span class="string">'|'</span>.join([s.string <span class="keyword">for</span> s <span class="keyword">in</span> spans])</span><br><span class="line">    p2 = ps[<span class="number">1</span>].string</span><br><span class="line">    job[<span class="string">'title'</span>] = h4</span><br><span class="line">    job[<span class="string">'info'</span>] = span</span><br><span class="line">    job[<span class="string">'desc'</span>] = p2</span><br><span class="line">    print(job)</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><p>该方法提取出的内容中包含换行、空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    print(list(aE.strings))</span><br></pre></td></tr></table></figure></li></ol><p>_注意_：</p><p>strings和stripped_strings、string属性和get_text方法：</p><ol><li>string：获取某个标签下的非标签字符串。返回值为字符串。</li><li>strings：获取某个标签下的所有非标签字符串，返回结果为一个生成器。</li><li>stripped_strings：获取某个标签下的所有非空行、非换行的非标签字符串，返回结果为一个生成器。</li><li>get_text：获取某个标签下的所有非标签字符串，返回结果为字符串。</li></ol></li></ul><h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><h4 id="find和find-all方法"><a href="#find和find-all方法" class="headerlink" title="find和find_all方法"></a>find和find_all方法</h4><p>搜索文档树，一般采用较多的是这两个方法，一个是find，另一个是find_all方法。find方法是在文档树中找到第一个满足条件的标签后就返回结果。find_all方法是在文档树中找到所有满足条件的标签后返回结果。在这两个方法中最常用的用法是name和attr参数，其中也可以直接传入关键字，在传入关键字”class”时，需要将”class”变为”class_”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'div'</span>, class_=<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><h4 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h4><p>在使用css选择器的方式时，需要使用select方法。以下为几种常用的css选择器方法：</p><ol><li><p>通过标签名查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">'a'</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过类名查找</p><p>通过类名，应该在前面加一个”.”,比如要查找class=sister的标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">'.sister'</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过id查找</p><p>通过id查找，应该在id的名字前面加一个”#”号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">'#link1'</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过组合查找</p><p>组合查找时，标签名和类名、id名进行组合的方式进行查找，例如查找p标签中，id等于link1的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">"p #link1"</span>))</span><br></pre></td></tr></table></figure><p>直接子标签查找，则用”&gt;”分隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">"head &gt; title"</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过属性查找</p><p>查找时还可以加入属性元素，属性元素需要使用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.select(<span class="string">'a[href="http://example.com/elsie"]'</span>))</span><br></pre></td></tr></table></figure></li><li><p>获取内容</p><p>以上的select方法返回的结果都是以列表的形式返回的，可以进行遍历输出，然后使用get_text()方法获取其他的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(type(soup.select(<span class="string">'title'</span>)))</span><br><span class="line">print(soup.select(<span class="string">'title'</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">'title'</span>):</span><br><span class="line">    print(title.get_text())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和lxml一样，BeautifulSoup也是一个HTML/XML的解析器，主要的功能也是解析和提取HTML/XML数据。&lt;/p&gt;
&lt;p&gt;lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有
      
    
    </summary>
    
      <category term="爬虫" scheme="http://quiryrain.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="bs4" scheme="http://quiryrain.tk/tags/bs4/"/>
    
  </entry>
  
  <entry>
    <title>XPath语法详解</title>
    <link href="http://quiryrain.tk/190628/"/>
    <id>http://quiryrain.tk/190628/</id>
    <published>2019-06-28T07:40:35.000Z</published>
    <updated>2019-06-28T09:36:47.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xpath语法和lxml模块"><a href="#Xpath语法和lxml模块" class="headerlink" title="Xpath语法和lxml模块"></a>Xpath语法和lxml模块</h3><h4 id="什么是XPath？"><a href="#什么是XPath？" class="headerlink" title="什么是XPath？"></a>什么是XPath？</h4><p>xpath (XML Path Language)是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p><h4 id="XPath开发工具"><a href="#XPath开发工具" class="headerlink" title="XPath开发工具"></a>XPath开发工具</h4><ol><li>Chrom插件XPath Helper</li><li>FireFox插件XPath Checker</li></ol><h4 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h4><h5 id="选取节点："><a href="#选取节点：" class="headerlink" title="选取节点："></a>选取节点：</h5><p>Xpath使用路径表达式选取XML文档中的节点或 节点集。</p><table><thead><tr><th>表达式</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有结点</td><td>bookstore</td><td>选取bookstore下所有的节点</td></tr><tr><td>/</td><td>如果是在最前面，代表从根节点选取。否者选取某节点下的某个节点</td><td>/bookstore</td><td>选取根元素下所有的bookstore节点</td></tr><tr><td>//</td><td>从全局节点中选择节点</td><td>//book</td><td>选取所有的bookstore节点</td></tr><tr><td>@</td><td>选取某个节点的属性</td><td>//book[@id]</td><td>选取所有拥有id属性的book节点</td></tr></tbody></table><h5 id="谓语："><a href="#谓语：" class="headerlink" title="谓语："></a>谓语：</h5><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取bookstore下的第一个book元素</td></tr><tr><td>/bookstore/book[last()]</td><td>选取bookstore下的倒数第二个book元素</td></tr><tr><td>/bookstore/book[position() &lt; 3]</td><td>选取bookstore下前两个book元素</td></tr><tr><td>//book[@id]</td><td>选取拥有id属性的所有book元素</td></tr><tr><td>//book[@id=10]</td><td>选取所有id=10的所有book元素</td></tr></tbody></table><h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h5><p><code>*</code> 表示通配符</p><table><thead><tr><th>通配符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>*</td><td>匹配任意节点</td><td>/bookstore/*</td><td>选取bookstore下所有的子元素</td></tr><tr><td>@*</td><td>匹配节点中的任何属性</td><td>//book[@*]</td><td>选取所有带有属性的book元素</td></tr></tbody></table><h5 id="选取多个路径："><a href="#选取多个路径：" class="headerlink" title="选取多个路径："></a>选取多个路径：</h5><p>通过在路径表达式中使用“|”运算符，可以选取若干路径。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bookstore/book | //book/title</span><br><span class="line">### 选取所有book元素以及book元素下所有的title元素</span><br></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>&#124;</td><td>计算两个节点集</td><td>//book &#124; //cd</td><td>返回所有拥有book 和cd元素的节点集</td></tr><tr><td>+</td><td>加法</td><td>6+4</td><td>10</td></tr><tr><td>-</td><td>减法</td><td>6-4</td><td>2</td></tr><tr><td>*</td><td>乘法</td><td>6*4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>=</td><td>等于</td><td>id=101</td><td>如果id=101，则返回True，否则返回False</td></tr><tr><td>!=</td><td>不等于</td><td>id != 101</td><td>如果id != 101，则返回True，否则返回False</td></tr><tr><td>&lt;</td><td>小于</td><td>id &lt; 101</td><td>如果id &gt; 101，则返回True，否则返回False</td></tr><tr><td>&lt;=</td><td>小于或等于</td><td>id &lt;= 101</td><td>如果id &lt;= 101，则返回True，否则返回False</td></tr><tr><td>></td><td>大于</td><td>id &gt; 101</td><td>如果id > 101，则返回True，否则返回False</td></tr><tr><td>>=</td><td>大于或等于</td><td>id &gt;= 101</td><td>如果id >= 101，则返回True，否则返回False</td></tr><tr><td>or</td><td>或</td><td>id =100 or id = 101</td><td>如果id = 100 或id=101，返回True， 否则返回False</td></tr><tr><td>and</td><td>与</td><td>id &gt; 100 and id &lt; 150</td><td>如果100 &lt; id &lt; 101,返回True，否则返回False</td></tr><tr><td>mod</td><td>计算除法的余数</td><td>5 mod 2</td><td>1</td></tr></tbody></table><p><em>注意:</em></p><ol><li><p>/和//的区别：/代表只获取直接子节点， //代表获取子孙节点。</p></li><li><p>contains：有时某个属性中包含多个值，可以使用模糊匹配的方式获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//div[contaions(@class, &apos;job_detail&apos;)]</span><br></pre></td></tr></table></figure></li></ol><h3 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h3><p>lxml是一个HTML/XML的解析器，主要的功能是如何解析和提取HTML/XML数据。</p><p>lxml和正则一样，也是C实现的，是一款高性能的Python HTML/XML解析器，它可以用来快速的定位特定元素以及节点信息。</p><p>安装：<code>pip install lxml</code></p><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><p>在用lxml解析HTML代码的时候，如果HTML代码不规范，lxml库会自动的将其补全。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lxml的etree库</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-0"&gt;&lt;a href="link0.html"&gt;First item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;Second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-inactive"&gt;&lt;a href="link2.html"&gt;Third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-1"&gt;&lt;a href="link3.html"&gt;Fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;Fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(html)</span>:</span></span><br><span class="line">    result = etree.tostring(html, encoding=<span class="string">'utf-8'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(result)</span><br><span class="line">    </span><br><span class="line">print_result(html)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link0.html"</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-inactive"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span>Fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span>Fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析html文件时，如果使用的<code>lxml.etree.parse</code>解析。该函数默认使用的解析器是<code>XML</code>解析器，所以，如果html文件中缺少相应标签，解析就会出错，此时可以自行创建解析器。</p><h4 id="lxml的使用"><a href="#lxml的使用" class="headerlink" title="lxml的使用"></a>lxml的使用</h4><p>以上文的text为例：</p><ul><li><p>获取ul标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uls = html.xpath(<span class="string">'//ul'</span>)</span><br><span class="line"><span class="keyword">for</span> ut <span class="keyword">in</span> uls:</span><br><span class="line">    print_result(ut)</span><br></pre></td></tr></table></figure></li><li><p>获取&lt;li class=”item-1”>标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li_items_1 = html.xpath(<span class="string">"//li[@class='item-1']"</span>)</span><br><span class="line"><span class="keyword">for</span> li_item_1 <span class="keyword">in</span> li_items_1:</span><br><span class="line">    print_result(li_item_1)</span><br></pre></td></tr></table></figure></li><li><p>获取所有&lt;li class=”item-1”>中a标签中的链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li_items_1_as_href = html.xpath(<span class="string">"//li[@class='item-1']/a/@href"</span>)</span><br><span class="line"><span class="keyword">for</span> li_items_1_a_href <span class="keyword">in</span> li_items_1_as_href:</span><br><span class="line">    print(li_items_1_a_href)</span><br></pre></td></tr></table></figure></li><li><p>获取所有a标签中的文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as_text = html.xpath(<span class="string">"//a/text()"</span>)</span><br><span class="line"><span class="keyword">for</span> a_text <span class="keyword">in</span> as_text:</span><br><span class="line">    print(a_text)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Xpath语法和lxml模块&quot;&gt;&lt;a href=&quot;#Xpath语法和lxml模块&quot; class=&quot;headerlink&quot; title=&quot;Xpath语法和lxml模块&quot;&gt;&lt;/a&gt;Xpath语法和lxml模块&lt;/h3&gt;&lt;h4 id=&quot;什么是XPath？&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="爬虫" scheme="http://quiryrain.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="XPath" scheme="http://quiryrain.tk/tags/XPath/"/>
    
  </entry>
  
  <entry>
    <title>Python 3中的Urllib库的使用</title>
    <link href="http://quiryrain.tk/190615/"/>
    <id>http://quiryrain.tk/190615/</id>
    <published>2019-06-15T07:17:25.000Z</published>
    <updated>2019-06-21T03:12:01.351Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。</p><p>在此处，使用Python3做记录。</p><h3 id="urlopen函数"><a href="#urlopen函数" class="headerlink" title="urlopen函数"></a>urlopen函数</h3><p>urlopen函数是request中的一个很常用的函数，它主要用于打开一个网页。其中有着很多的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">resp = request.open(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure><h3 id="urlretrieve函数"><a href="#urlretrieve函数" class="headerlink" title="urlretrieve函数"></a>urlretrieve函数</h3><p>urlretrieve函数可以很方便的将网页保存至本地。其实用方法见下方代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">request.urlretrieve()</span><br></pre></td></tr></table></figure><h3 id="urlencode函数"><a href="#urlencode函数" class="headerlink" title="urlencode函数"></a>urlencode函数</h3><p>将字典类型的数据转化为url编码的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">"wd"</span>: <span class="string">"爬虫之道"</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line"></span><br><span class="line">url = <span class="string">f"https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(url)</span><br></pre></td></tr></table></figure><h3 id="parse-qs函数"><a href="#parse-qs函数" class="headerlink" title="parse_qs函数"></a>parse_qs函数</h3><p>将url编码后的参数还原为字典形式，其中的值以列表形式进行存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">ps = &#123;<span class="string">"name"</span>: <span class="string">"爬虫之道"</span>, <span class="string">"vxcode"</span>: <span class="string">"spider_rold"</span>&#125;</span><br><span class="line"></span><br><span class="line">results = parse.urlencode(ps)</span><br><span class="line"></span><br><span class="line">new_results = parse.parse_qs(results)</span><br><span class="line">print(new_results)</span><br></pre></td></tr></table></figure><h3 id="urlparse和urlsplit函数"><a href="#urlparse和urlsplit函数" class="headerlink" title="urlparse和urlsplit函数"></a>urlparse和urlsplit函数</h3><p>对URL各部分进行分割，其中在使用urlsplit函数时，没有<em>params</em>参数。（<em>注</em>：params参数指的是在以下链接中”?”前添加”;”，位于这两者之间的内容，如：<em><a href="https://www.baidu.com/s;hello?wd=hello+world" target="_blank" rel="noopener">https://www.baidu.com/s;hello?wd=hello+world</a></em>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">"wd"</span>: <span class="string">"爬虫之道"</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f"https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'scheme:'</span>, result.scheme)</span><br><span class="line">print(<span class="string">'netloc:'</span>, result.netloc)</span><br><span class="line">print(<span class="string">'path:'</span>, result.path)</span><br><span class="line">print(<span class="string">'params:'</span>, result.params)</span><br><span class="line">print(<span class="string">'query:'</span>, result.query)</span><br><span class="line">print(<span class="string">'fragment:'</span>, result.fragment)</span><br></pre></td></tr></table></figure><h3 id="request-Request类"><a href="#request-Request类" class="headerlink" title="request.Request类"></a>request.Request类</h3><p>在爬虫中，如果想使用一些参数，如：请求头，请求数据等，需要使用到Request类。如果只是使用urlopen函数，没有办法进行添加请求头。在没有使用<em>User-Agent</em>的时候，如果服务器发现是爬虫，服务器可能会返回一条假的数据内容，或者是不返回内容。所以，将爬虫程序伪装成正常的浏览器访问是很有必要的一件事。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'user-agent'</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36"</span>&#125;</span><br><span class="line">params = &#123;<span class="string">"wd"</span>: <span class="string">"爬虫之道"</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f"https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">req = request.Request(url, headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure><p>注： 可以去挑战一下网络爬虫界的“珠穆朗玛峰” —– 拉勾网</p><h3 id="ProxyHandler处理器"><a href="#ProxyHandler处理器" class="headerlink" title="ProxyHandler处理器"></a>ProxyHandler处理器</h3><p>在爬取网站时，一般情况下网站都会做一些反爬虫机制，如封ip。如果只使用一个ip地址进行爬取，在网站封掉ip地址后，就无法获取数据了。所以，在有反爬虫机制的情况，反反爬虫机制便可以使用了。在urllib中通过使用ProxyHandler进行设置代理服务器。</p><p>在使用代理与未使用代理的区别：</p><p><img src="/userImages/proxy.jpg" alt>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment">### 未使用代理</span></span><br><span class="line">resp = request.urlopen(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">print(resp.read())</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用代理</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">"https"</span>: <span class="string">"58.253.152.231:9999"</span>&#125;)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">req = request.Request(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">resp = opener.open(req)</span><br><span class="line">print(resp.read())</span><br></pre></td></tr></table></figure><p>常用的代理：</p><ul><li>西刺代理：<a href="https://www.xicidaili.com" target="_blank" rel="noopener">https://www.xicidaili.com</a></li><li>快代理: <a href="https://www.kuaidaili.com/free/" target="_blank" rel="noopener">https://www.kuaidaili.com/free/</a></li></ul><h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>在网站汇总，http请求是无状态的。在第一次和服务器建立连接登录后，第二次请求服务器依旧不能知道当前请求的用户是谁。Cookie的出现就是为了解决该问题。第一次登录后，服务器会返回一些数据(cookie) 给浏览器，然后浏览器将数据保存在本地。当用户发送第二次请求时，浏览器会自动的将保存在本地的数据(cookie)一起发送给服务器。服务通过判断不同的cookie信息，进行确认用户。cookie的存储大小是有限的一般不会超过4KB，因此在设置cookie对的时候，只能存储少量数据。</p><h4 id="cookie的格式："><a href="#cookie的格式：" class="headerlink" title="cookie的格式："></a>cookie的格式：</h4><p>Set-Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE</p><p>参数含义：</p><ul><li>NAME：Cookie的名字</li><li>VALUE：Cookie的值</li><li>Expires:  Cookie的过期时间</li><li>Path：Cookie作用的路径</li><li>Domain： Cookie作用的域名</li><li>SECURE：是否只在HTTP协议下起作用</li></ul><h3 id="使用cookielib库和HTTPCookieProcessor模块模拟登陆"><a href="#使用cookielib库和HTTPCookieProcessor模块模拟登陆" class="headerlink" title="使用cookielib库和HTTPCookieProcessor模块模拟登陆"></a>使用cookielib库和HTTPCookieProcessor模块模拟登陆</h3><p>在Python中使用cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器一起使用的。</p><ul><li>http.cookiejar：提供用于存储cookie的对象</li><li>HTTPCookieProcessor：处理cookie对象并构建handler对象</li></ul><h4 id="http-cookiejar模块"><a href="#http-cookiejar模块" class="headerlink" title="http.cookiejar模块"></a>http.cookiejar模块</h4><p>在该模块中主要有三个类，CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。其作用如下：</p><ul><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie失效。</li><li>FileCookieJar (filename, delayload=None, policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例。检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名，delayload为True是支持延迟访问文件，即只有在需要时才读取文件或将数据存储在文件中。</li><li>MozillaCookieJar (filename, delayload=None, policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename, delayload=None, policy=None)：从FileCookieJar派生而来，创建与libwww·per标准的Set-Cookies3文件格式兼容的FileCookieJar实例。</li></ul><h3 id="保存Cookie至本地"><a href="#保存Cookie至本地" class="headerlink" title="保存Cookie至本地"></a>保存Cookie至本地</h3><p>保存cookie到本地，可以使用cookiejar的save方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">'cookies.txt'</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">handlers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">'http://httpbin.org/cookies'</span>, headers=handlers)</span><br><span class="line"></span><br><span class="line">resp = opener.open(req)</span><br><span class="line">print(resp.read())</span><br><span class="line"></span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="加载本地cookie"><a href="#加载本地cookie" class="headerlink" title="加载本地cookie"></a>加载本地cookie</h3><p>从本地文件读取cookie信息，可以使用cookiejar中的load方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">'cookies.txt'</span>)</span><br><span class="line">cookiejar.load(ignore_discard=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    print(cookie)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。&lt;/p&gt;
&lt;p&gt;在此处，使用Python3做记录。&lt;/p&gt;
&lt;h3 id=&quot;u
      
    
    </summary>
    
      <category term="爬虫" scheme="http://quiryrain.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="urllib" scheme="http://quiryrain.tk/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>为Next加上彩色标签云</title>
    <link href="http://quiryrain.tk/190520/"/>
    <id>http://quiryrain.tk/190520/</id>
    <published>2019-05-20T10:02:00.000Z</published>
    <updated>2019-06-15T03:05:48.825Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（<a href="https://me.idealli.com/post/d6caa003.html" target="_blank" rel="noopener">传送门</a>），在此也做下记录吧！</p><ol><li><p>打开themes –> next –> layout –> page.swig文件</p></li><li><p>找到<code>{ % if page.type === &#39;tags&#39; % }</code></p></li><li><p>将下方代码进行替换即可</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">  &#123;% if not theme.tagcloud %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">修改之后的内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot; id=&quot;tags&quot;&gt;</span><br><span class="line">  &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &apos;#fff&apos;, end_color: &apos;#fff&apos;&#125;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var alltags=document.getElementById(&apos;tags&apos;);</span><br><span class="line">  var tags=alltags.getElementsByTagName(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">  for (var i = tags.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    var r=Math.floor(Math.random()*75+130);</span><br><span class="line">    var g=Math.floor(Math.random()*75+100);</span><br><span class="line">    var b=Math.floor(Math.random()*75+80);</span><br><span class="line">    tags[i].style.background = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  div#posts.posts-expand .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-left: 10px;</span><br><span class="line">    padding-right: 10px;</span><br><span class="line">    margin-top: 18px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin-right: 5px;</span><br><span class="line">    margin-left: 0px;</span><br><span class="line">    margin-top: 8px;</span><br><span class="line">    margin-bottom: 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a:before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    text-align: left;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>之后清理缓存，重新部署就行了。</p><p>最终效果如下：</p><p><img src="/userImages/tag-cloud.png" alt="彩色标签云"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（&lt;a href=&quot;https://me.idealli.com/post/d6caa003.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;），在此也做
      
    
    </summary>
    
      <category term="起始篇" scheme="http://quiryrain.tk/categories/%E8%B5%B7%E5%A7%8B%E7%AF%87/"/>
    
    
      <category term="标签云" scheme="http://quiryrain.tk/tags/%E6%A0%87%E7%AD%BE%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>那天一切都结束了</title>
    <link href="http://quiryrain.tk/190517/"/>
    <id>http://quiryrain.tk/190517/</id>
    <published>2019-05-17T12:16:52.000Z</published>
    <updated>2019-07-02T10:06:06.978Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+uDgJsw45Bkv65RMqr+w44znJch19QSq7EYCFG7nlWVqqBXEjbrdgkYQkWXQGkQ+w/45/9AmrLoHeyt71gZEMT/EOYxJPsWaejpMxIhpioC50+g4z2dyBamh14UcPd/cCjXI4QdNSDbuJt0+8lzNIjCl24fmp4xenH3FSqGo2cZmP7uCjUg4t/H6tNoNjdnnOS94WosYVTRkPmOxTGIgeHlEdZ1iegHa5zdIcdYzgqasq1eSi8mq11smF+HfUZUGPLcMYkiDTT7AKgR7h1SKxmHMmw0q056lNqwiFHOiavfUgYOb5jrDIPieESDMxf1wvi9CMwPo3WKfl9aGtClTMabxfNr8X0jdaEUJ5wbhAIcYxFfamZb1m1JAwvTSce3jG4DRa+GyFKkvd1C0H5KA8X/n+UbeISUtRAmhOS9d3cwClNC1Q/YV9rctkIVCuyeI96lNDPBohoHCNN2vy5xmnDtV0SXrRQZJFLy4x9J2meOrwQfKSN0S38VT54yEsqwYFMj30P9OPdzioFCnokyZtnZ3sUyoXjfb2HlprVLTtGJ/fqqUSUH+WHTavZuNzDiPv73BEb6hDckuHqj/NMOgfxOzjl4/p7WQvOsgHUbrcbTSIJKBKzegU90yvXYA2s3WJMNreLGNOUvFy07IClhHMYqqC6QAubjS6lkTJh8A6sZvfbHlOaWT87ZiYtf/zZf4csXzuCHMhTM+v1XLeNzJ/SWTa/iZ2b4/UuskE+s9ynqTAb6duwNUuz9k10guDBWb9PDVkv1pN96pVLdhc0zJM7Adkjdg5WoL5ytV6Rj3VYjIMU2G+rP5u2OXLjLfVemrxg4vwxs/gtqQ==</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    <summary type="html">
    
      个人心情
    
    </summary>
    
      <category term="往事回廊" scheme="http://quiryrain.tk/categories/%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BB%8A/"/>
    
    
      <category term="大学" scheme="http://quiryrain.tk/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用Cython保护Python文件</title>
    <link href="http://quiryrain.tk/190502-4/"/>
    <id>http://quiryrain.tk/190502-4/</id>
    <published>2019-05-02T04:02:58.000Z</published>
    <updated>2019-06-15T03:05:48.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Cython保护Python代码库"><a href="#使用Cython保护Python代码库" class="headerlink" title="使用Cython保护Python代码库"></a>使用Cython保护Python代码库</h1><p>从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux/Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式：</p><blockquote><ul><li>(推荐) 通过setup.py中调用Cython.Build进行编译</li><li>使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件</li><li>在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库</li><li>使用Jupyter Notebook或者Sage Notebook直接运行Cython代码  </li></ul></blockquote><p>这上面四种方法里最简单的是第三种方法。运行<code>cythonize -i &lt;.pyx File&gt;</code>即可编译.pyx成二进制库，并保存在与.pyx文件相同的目录下。cythonize命令有其他的参数，可以通过命令行查看。这个命令也可以通过<code>python -m Cython.Build.Cythonize -i &lt;.pyx File&gt;</code>来完成。</p><p>  在对Python 代码进行保护时，可以采用Cython对Python代码记性二进制转换，尽管可以对二进制文件进行逆向工程，但是依然会起到一定的保护作用.</p><h2 id="对项目包进行编译"><a href="#对项目包进行编译" class="headerlink" title="对项目包进行编译"></a>对项目包进行编译</h2><p>对以下结构的包进行编译:</p><p><img src="/userImages/Cython_tree.png" alt="tree"></p><ul><li>通过<code>setup.py</code>文件进行简单编译</li></ul><p>在使用该方法编译的时候，一个函数只有一个参数时，有可能会出现无法找到函数的情况，鉴于这种情况，请参考复杂编译的过程。以Cython官方实例为例：</p><p><code>setup.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">  name = <span class="string">'Hello world app'</span>,</span><br><span class="line">  ext_modules = cythonize(<span class="string">"hello.py"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>hello.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello_to</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello %s!"</span> % name)</span><br></pre></td></tr></table></figure><p><img src="/userImages/Cython_example1.png" alt="example1"></p><p>运行<code>python setup.py build_ext --inplace</code>，生成<code>.so</code>文件，删除该文件夹中的<code>py文件</code>和<code>c文件</code>。<br>在终端导入使用：<br><img src="/userImages/Cython_example2.png" alt="example2"></p><ul><li>使用<code>setup.py</code>文件进行复杂编译</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> setuptools.extension <span class="keyword">import</span> Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"><span class="keyword">from</span> Cython.Distutils <span class="keyword">import</span> build_ext</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ext_modules=cythonize(</span><br><span class="line">        [</span><br><span class="line">            Extension(<span class="string">'mypkg.*'</span>, [<span class="string">'mypkg/*.py'</span>]),</span><br><span class="line">            Extension(<span class="string">'mypkg.submypkg1.*'</span>, [<span class="string">'mypkg/submypkg1/*.py'</span>]),</span><br><span class="line">            Extension(<span class="string">'mypkg.submypkg2.*'</span>, [<span class="string">'mypkg/submypkg2/*.py'</span>]),</span><br><span class="line">            Extension(<span class="string">'mypkg2.*'</span>, [<span class="string">'mypkg2/*.py'</span>]),</span><br><span class="line">        ],</span><br><span class="line">        build_dir=<span class="string">'build'</span>,</span><br><span class="line">        compiler_directives=dict(</span><br><span class="line">            always_allow_keywords=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    cmdclass = dict(</span><br><span class="line">        build_ext=build_ext</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── mypkg</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   ├── __init__.c</span><br><span class="line">│   │   ├── submypkg1</span><br><span class="line">│   │   │   ├── bar.c</span><br><span class="line">│   │   │   ├── foo.c</span><br><span class="line">│   │   │   └── __init__.c</span><br><span class="line">│   │   └── submypkg2</span><br><span class="line">│   │       ├── bar.c</span><br><span class="line">│   │       ├── foo.c</span><br><span class="line">│   │       └── __init__.c</span><br><span class="line">│   ├── mypkg2</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   └── __init__.c</span><br><span class="line">│   └── temp.linux-x86_64-3.7</span><br><span class="line">│       └── build</span><br><span class="line">│           ├── mypkg</span><br><span class="line">│           │   ├── bar.o</span><br><span class="line">│           │   ├── foo.o</span><br><span class="line">│           │   ├── __init__.o</span><br><span class="line">│           │   ├── submypkg1</span><br><span class="line">│           │   │   ├── bar.o</span><br><span class="line">│           │   │   ├── foo.o</span><br><span class="line">│           │   │   └── __init__.o</span><br><span class="line">│           │   └── submypkg2</span><br><span class="line">│           │       ├── bar.o</span><br><span class="line">│           │       ├── foo.o</span><br><span class="line">│           │       └── __init__.o</span><br><span class="line">│           └── mypkg2</span><br><span class="line">│               ├── bar.o</span><br><span class="line">│               ├── foo.o</span><br><span class="line">│               └── __init__.o</span><br><span class="line">├── mypkg</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── submypkg1</span><br><span class="line">│   │   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── bar.py</span><br><span class="line">│   │   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── foo.py</span><br><span class="line">│   │   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   └── submypkg2</span><br><span class="line">│       ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── bar.py</span><br><span class="line">│       ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── foo.py</span><br><span class="line">│       ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       └── __init__.py</span><br><span class="line">├── mypkg2</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure></p><ul><li>运行文件<code>python setup.py build_ext --inplace</code></li><li>最终会在当前文件夹中生成build文件夹，同时在build文件夹中生成相应的文件夹和<code>.c</code>文件，在主目录对应的文件夹中生成<code>.so</code>文件，此时的<code>.so</code>文件就可以通过导入的方式直接使用。</li><li>如果需求有改动，需要删除相应的<code>.so文件</code>后重新生成该文件。</li></ul><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>此<code>always_allow_keywords=True</code>参数一定要添加，因为<code>always_allow_keywords</code>指令禁用具有大量参数的函数只允许使用关键字参数，如果不禁用，此处在传入一个参数时会找不到对应的函数。</li><li><p>在使用第二种方法时，一定要注意一点，在有celery task任务的文件中，无法进行编译，否则在编译过后会出现celery无法启动的情况。</p><ul><li><p>对上文出现的问题进行给出一个解答：<br>在上文中，如果编译了带有task任务的文件，会出现以下错误  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">'method-wrapper'</span> object has no attribute <span class="string">'__module__'</span></span><br></pre></td></tr></table></figure><p>解决方法为：  </p><blockquote><ul><li>创建第三方真实执行逻辑的文件，在进行加密时，加密第三方逻辑文件，对celery调度任务的文件不进行加密。</li><li>见官方给出的解决方式<a href="https://github.com/celery/celery/issues/4342" target="_blank" rel="noopener">Issues</a>，不过此处不建议更改celery源文件。</li></ul></blockquote></li></ul></li></ul><hr><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://bucharjan.cz/blog/using-cython-to-protect-a-python-codebase.html" target="_blank" rel="noopener">Using Cython to protect a Python codebase</a></li><li><a href="https://python.freelycode.com/contribution/detail/981" target="_blank" rel="noopener">对《Using Cython to protect a Python codebase》的翻译</a></li><li><a href="http://docs.cython.org/en/latest/" target="_blank" rel="noopener">Cython Documentation</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Cython保护Python代码库&quot;&gt;&lt;a href=&quot;#使用Cython保护Python代码库&quot; class=&quot;headerlink&quot; title=&quot;使用Cython保护Python代码库&quot;&gt;&lt;/a&gt;使用Cython保护Python代码库&lt;/h1&gt;&lt;p&gt;从语
      
    
    </summary>
    
      <category term="Cython" scheme="http://quiryrain.tk/categories/Cython/"/>
    
    
      <category term="加密" scheme="http://quiryrain.tk/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="Cython" scheme="http://quiryrain.tk/tags/Cython/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL学习总结</title>
    <link href="http://quiryrain.tk/190502-3/"/>
    <id>http://quiryrain.tk/190502-3/</id>
    <published>2019-05-02T03:42:09.000Z</published>
    <updated>2019-06-15T03:05:48.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PG数据库："><a href="#PG数据库：" class="headerlink" title="PG数据库："></a>PG数据库：</h1><p>理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库中，用户可以指定表集合，这点和mongodb很像。</p><blockquote><p>模式(架构)：是指定的表集合，它还可以包含视图、索引、序列、数据类型、运算符和函数.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建模式:create schema &lt;schemaname&gt;</span><br></pre></td></tr></table></figure><h1 id="架构作用"><a href="#架构作用" class="headerlink" title="架构作用:"></a>架构作用:</h1><blockquote><p>1、模式有助于多用户使用一个数据库,而不会互相干扰</p><p>2、将数据库对象组织成逻辑组,使其更易于管理</p><p>3、可以将第三方模式放入单独的模式中,以避免与其他对象的名称相冲突</p></blockquote><h1 id="PostgreSQL中的连接类型："><a href="#PostgreSQL中的连接类型：" class="headerlink" title="PostgreSQL中的连接类型："></a>PostgreSQL中的连接类型：</h1><ul><li><p>内连接（inner join）显示两个集合共有部分（交集）</p><p>  select table1.columns,table2.columns from table1 inner join table2 on table1.common_filed = table2.common_filed;</p></li><li><p>左外连接（left outer join）显示左集合的全部，右集合不满足的用空补全</p><p>  select table1.columns,table2.columns from table1 left outer join table2 on table1.common_filed = table2.common_filed;</p></li><li><p>右外连接（right outer join）显示右集合的全部，左集合不满足的用空补全</p><p>  select table1.columns,table2.columns from table1 right outer join table2 on table1.common_filed = table2.common_filed;</p></li><li><p>全连接（full outer join）显示两个集合的全部，不满足条件的用空补全</p><p>  select table1.columns,table2.columns from table1 full outer join table2 on table1.common_filed = table2.common_filed;</p></li><li><p>跨连接（cross join）将第一个表的每一行与第二个表的每一行相匹配。</p><p>  select coloums from table1 cross join table2;</p></li><li><p>having子句和group by子句组合使用，用于选择函数结果满足某些条件的特定行。</p></li></ul><h1 id="普通用户创建与登陆："><a href="#普通用户创建与登陆：" class="headerlink" title="普通用户创建与登陆："></a>普通用户创建与登陆：</h1><blockquote><p>1、登陆超级用户：sudo -u postgres psql</p><p>2、创建用户：create user dbuser encrypted password ‘test’;</p><p>3、授权：alter user dbuser with createdb; alter user dbuser with login;</p><p>4、创建dbuser用户的数据集：create database dbusers with owner=’dbuser’;</p><p>5、退出\q</p><p>6、普通用户登陆：psql -U dbuser -d dbusers -h localhost</p></blockquote><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">function</span> auditlogfunc() <span class="keyword">returns</span> <span class="keyword">trigger</span> <span class="keyword">as</span> $example_table$</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">audit</span>(emp_id,entry_date) <span class="keyword">values</span> (new.ID, <span class="keyword">current_timestamp</span>);</span><br><span class="line">return new</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$example_table$ language plpgsql;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> example_trigger <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> company <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">execute</span> <span class="keyword">procedure</span> auditlogfunc();</span><br></pre></td></tr></table></figure><blockquote><p>PostgreSQL触发器目的：</p><p>1、验证输入数据</p><p>2、执行业务规则</p><p>3、为不同文件中新插入的行生成唯一值</p><p>4、写入其他文件以急性审计跟踪</p><p>5、从其他文件查询交叉引用目的</p><p>6、访问系统函数</p><p>7、将数据复制到不同的文件以实现数据一致性</p></blockquote><h1 id="触发器的查询、删除："><a href="#触发器的查询、删除：" class="headerlink" title="触发器的查询、删除："></a>触发器的查询、删除：</h1><ul><li>列出当前数据库的所有触发器：select * from pg_trigger;</li><li>列出某张表上的触发器：SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid=pg_class.oid AND relname=’\<tablename>‘;</tablename></li><li>删除触发器：drop trigger &lt;trigger_name&gt;;</li></ul><h1 id="查询创建的函数："><a href="#查询创建的函数：" class="headerlink" title="查询创建的函数："></a>查询创建的函数：</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">pg_proc.proname <span class="keyword">AS</span> <span class="string">"函数名称"</span>,</span><br><span class="line">pg_type.typname <span class="keyword">AS</span> <span class="string">"返回值数据类型"</span>,</span><br><span class="line">pg_proc.pronargs <span class="keyword">AS</span> <span class="string">"参数个数"</span> </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">pg_proc </span><br><span class="line"><span class="keyword">JOIN</span> pg_type <span class="keyword">ON</span> (pg_proc.prorettype = pg_type.oid) </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">pg_type.typname != <span class="string">'void'</span> </span><br><span class="line"><span class="keyword">AND</span> </span><br><span class="line">pronamespace = (<span class="keyword">SELECT</span> pg_namespace.oid <span class="keyword">FROM</span> pg_namespace <span class="keyword">WHERE</span> nspname = <span class="string">'public'</span>);</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>用于加速从数据库中检索数据</p><blockquote><p>创建索引:create index index_name on table_name;</p></blockquote><p>响应时间的计算模型：<br>响应时间=网络传输时间（请求）+服务器处理时间（一层或是多层）+网络传输时间（响应）+页面前段解析时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PG数据库：&quot;&gt;&lt;a href=&quot;#PG数据库：&quot; class=&quot;headerlink&quot; title=&quot;PG数据库：&quot;&gt;&lt;/a&gt;PG数据库：&lt;/h1&gt;&lt;p&gt;理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库
      
    
    </summary>
    
      <category term="PostgreSQL" scheme="http://quiryrain.tk/categories/PostgreSQL/"/>
    
    
      <category term="学习总结" scheme="http://quiryrain.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="PostgreSQL" scheme="http://quiryrain.tk/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Git学习总结</title>
    <link href="http://quiryrain.tk/190502-2/"/>
    <id>http://quiryrain.tk/190502-2/</id>
    <published>2019-05-02T03:39:40.000Z</published>
    <updated>2019-06-15T03:05:48.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git整理："><a href="#git整理：" class="headerlink" title="git整理："></a>git整理：</h1><blockquote><p>工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git commit将文件提交到本地仓库，git push将文件提交到远程仓库。</p></blockquote><h1 id="历史版本回退及提交至远程仓库"><a href="#历史版本回退及提交至远程仓库" class="headerlink" title="历史版本回退及提交至远程仓库"></a>历史版本回退及提交至远程仓库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  可以回退版本  当回退多个版本时可以使用 HEAD~100（恢复到第100个版本）。</span><br><span class="line">git reflog 用于记录每次的命令，最上方为最近一次的命令</span><br><span class="line">git reset HEAD &lt;file&gt; 将缓存区中的修改回退到工作区。</span><br><span class="line">git checkout -- &lt;file&gt; 将版本库中的版本替换工作区的版本，可以做恢复用。</span><br><span class="line">git push 将当前分支master推送到远程</span><br><span class="line">git commit 将缓存区中的文件推送到分支master(本地)</span><br></pre></td></tr></table></figure><h1 id="分支的创建、切换与合并"><a href="#分支的创建、切换与合并" class="headerlink" title="分支的创建、切换与合并"></a>分支的创建、切换与合并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; 创建一个分支并切换，等同于git branch &lt;branch&gt; git checkout &lt;branch&gt;两条命令</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git merge 命令用于合并指定分支到当前分支</span><br><span class="line">git branch -d &lt;branch&gt; 删除分支</span><br><span class="line">git log --graph 可以查看分支合并图</span><br></pre></td></tr></table></figure><h1 id="对远程分支进行操作"><a href="#对远程分支进行操作" class="headerlink" title="对远程分支进行操作"></a>对远程分支进行操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete branch &lt;branchname&gt;或git push origin :&lt;branchname&gt; 删除远程仓库中的分支</span><br></pre></td></tr></table></figure><blockquote><p>重命名远程分支：<br>1、删除远程分支：git push –delete origin <branchname><br>2、重命名本地分支：git branch -m <old> <new><br>3、推送本地分支：git push origin <newbranchname></newbranchname></new></old></branchname></p></blockquote><h1 id="提交出错解决方法"><a href="#提交出错解决方法" class="headerlink" title="提交出错解决方法"></a>提交出错解决方法</h1><p>如果在提交远程仓库的时候出现“更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支”，此时应该先获取远程更新,然后合并本地的分支，最后提交.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin;# 获取运程仓库</span><br><span class="line">git merge origin/master# 将本地仓库与远程仓库合并</span><br><span class="line"></span><br><span class="line">git pull = git fetch + git merge 可能会产生冲突，需要手动解决</span><br><span class="line"></span><br><span class="line">--no-ff 参数表示禁用Fast forward</span><br></pre></td></tr></table></figure><p>如果出现”您要求从远程 ‘origin’ 拉取，但是未指定一个分支。因为这不是当前分支默认的远程仓库，您必须在命令行中指定一个分支名。”<br>执行以下内容：<br><code>git branch --set-upstream-to corigin/master master</code></p><h2 id="出错时"><a href="#出错时" class="headerlink" title="出错时"></a>出错时</h2><p>出错内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &apos;https://github.com/bnq456/bnq456.github.io.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure></p><ul><li>强制推送<br>在确定自己仓库中的内容低于本地仓库中的内容并且确定本地优于远程时，如果无法进行推送，可以选择强制推送<br><code>git push -u origin master -f</code></li><li><p>push前先将远程repository修改pull下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li><li><p>若不想merge远程和本地修改，可以先创建新的分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch [name]</span><br><span class="line">然后push</span><br><span class="line">git push -u origin [name]</span><br></pre></td></tr></table></figure></li></ul><h2 id="fetch-和-pull的区别："><a href="#fetch-和-pull的区别：" class="headerlink" title="fetch 和 pull的区别："></a>fetch 和 pull的区别：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch：将远程主机的最新内容拉取到本地，是否合并由用户决定。</span><br><span class="line">git pull：将远程主机的最新内容拉取到本地后直接合并，可能会产生冲突，需要手动解决。</span><br><span class="line">解决方法：</span><br><span class="line">git reset --hard FETCH_HEAD</span><br><span class="line">git pull</span><br><span class="line">注：将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或HEAD，还需要--hard。当后面没有hard，不会冲掉本地工作区，只会冲掉stage区。</span><br></pre></td></tr></table></figure><p><img src="/userImages/fetch_and_pull.png" alt="fetch和pull的不同"></p><h1 id="Git中工作环境的临时存储与恢复"><a href="#Git中工作环境的临时存储与恢复" class="headerlink" title="Git中工作环境的临时存储与恢复"></a>Git中工作环境的临时存储与恢复</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash 把当前工作现场存储起来，用于以后恢复现场继续工作</span><br><span class="line">切换回工作时：</span><br><span class="line">git stash list 列出所有存储的工作环境</span><br><span class="line">result: stash@&#123;0&#125;: WIP on dev: cc559a8 add merge</span><br><span class="line">git stash pop 切回工作场景，或git stash apply stash@&#123;0&#125; 恢复后不删除stash中的内容，需要使用git stash drop &lt;name&gt;删除</span><br></pre></td></tr></table></figure><blockquote><p>pop和 apply的区别<br>pop是将工作环境切回后直接删除<br>apply是先应用工作环境，然后存储的工作环境是否删除由用户自己决定。使用：git stash drop <name>进行删除</name></p></blockquote><blockquote><p>实验性质的代码最好新建分支</p></blockquote><h1 id="分支的创建、删除、合并与推送"><a href="#分支的创建、删除、合并与推送" class="headerlink" title="分支的创建、删除、合并与推送"></a>分支的创建、删除、合并与推送</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br><span class="line">git checkout &lt;branchname&gt;</span><br><span class="line">以上两条命令等同于git checkout -b &lt;branchname&gt;</span><br><span class="line">git branch -D &lt;name&gt; 表示强行删除一个分支</span><br><span class="line">git merge &lt;branchname&gt; 分支的合并，表示要将&lt;branchname&gt;分支合并到当前分支上</span><br><span class="line"></span><br><span class="line">分支的推送：</span><br><span class="line">master分支是主分支，因此要时刻与远程同步;</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以需要时刻与远程同步;</span><br><span class="line">bug分支是本地修复bug，可推送可不推送;</span><br><span class="line">feature分支取决与是否在上面进行开发。</span><br></pre></td></tr></table></figure><h1 id="多人协作："><a href="#多人协作：" class="headerlink" title="多人协作："></a>多人协作：</h1><blockquote><p>1、首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></p></blockquote><blockquote><p>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></blockquote><blockquote><p>3、如果合并有冲突，则解决冲突，并在本地提交；</p></blockquote><blockquote><p>4、没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></p></blockquote><blockquote><p>5、如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p></blockquote><h1 id="rebase：（不是很了解）"><a href="#rebase：（不是很了解）" class="headerlink" title="rebase：（不是很了解）"></a>rebase：（不是很了解）</h1><blockquote><p>rebase操作可以将本地未push的分叉提交历史整理成一条直线;<br>rebase的目的是使我们在查看提交的变化时更容易，因为分叉的提交需要三方比较。</p></blockquote><h1 id="git-标签："><a href="#git-标签：" class="headerlink" title="git 标签："></a>git 标签：</h1><p>git tag <name>用于新建一个标签,默认为HEAD，当创建带有说明的标签时，用-a指定标签名，-m指定说明文字<br>git tag可以查看所有的标签<br>当给以前忘记打标签的项目打标签时，可以先找出要打标签项目的编号，然后git tag <tagname> <commit id><br>-d用于删除标签<br>    远程标签推送：<br>    git push origin <tagname>推送一个本地标签到远程<br>    git push origin –tags 将所有标签推送到远程</tagname></commit></tagname></name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当删除远程标签时：</span><br><span class="line">1、首先先删除本地的标签 git tag -d &lt;tagname&gt;</span><br><span class="line">2、然后删除远程的标签 git push origin :refs/tags/&lt;tagname&gt;或者git push origin --delete tag &lt;tagname&gt;（作用与上两步相同）</span><br></pre></td></tr></table></figure><h1 id="日志文件查询"><a href="#日志文件查询" class="headerlink" title="日志文件查询"></a>日志文件查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git整理：&quot;&gt;&lt;a href=&quot;#git整理：&quot; class=&quot;headerlink&quot; title=&quot;git整理：&quot;&gt;&lt;/a&gt;git整理：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git c
      
    
    </summary>
    
      <category term="Git" scheme="http://quiryrain.tk/categories/Git/"/>
    
    
      <category term="学习总结" scheme="http://quiryrain.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="Git" scheme="http://quiryrain.tk/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习总结</title>
    <link href="http://quiryrain.tk/190502-1/"/>
    <id>http://quiryrain.tk/190502-1/</id>
    <published>2019-05-02T03:37:44.000Z</published>
    <updated>2019-06-15T03:05:48.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-中的三个基本概念"><a href="#Docker-中的三个基本概念" class="headerlink" title="Docker 中的三个基本概念"></a>Docker 中的三个基本概念</h2><ul><li>镜像(Image)</li><li>容器(Container)</li><li>仓库(Repository)</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会改变</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>是镜像的运行时实例 - 实际执行时镜像会在内存中变成什么。默认情况下，它完全独立于主机环境运行，仅在配置为访问主机文件和端口的情况下才执行此操作。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .<span class="comment"># 使用此目录的 Dockerfile 创建镜像</span></span><br><span class="line">docker <span class="keyword">run</span> -p 4000:80 friendlyname  # 运行端口 4000 到 90 的“友好名称”映射</span><br><span class="line">docker <span class="keyword">run</span> -d -p 4000:80 friendlyname         # 内容相同，但在分离模式下</span><br><span class="line">docker ps                                 <span class="comment"># 查看所有正在运行的容器的列表</span></span><br><span class="line">docker stop &lt;hash&gt;                     <span class="comment"># 平稳地停止指定的容器</span></span><br><span class="line">docker ps -a           <span class="comment"># 查看所有容器的列表，甚至包含未运行的容器</span></span><br><span class="line">docker kill &lt;hash&gt;                   <span class="comment"># 强制关闭指定的容器</span></span><br><span class="line">docker rm &lt;hash&gt;              <span class="comment"># 从此机器中删除指定的容器</span></span><br><span class="line">docker rm $(docker ps -a -q)           <span class="comment"># 从此机器中删除所有容器</span></span><br><span class="line">docker images -a                               <span class="comment"># 显示此机器上的所有镜像</span></span><br><span class="line">docker rmi &lt;imagename&gt;            <span class="comment"># 从此机器中删除指定的镜像</span></span><br><span class="line">docker rmi $(docker images -q)             <span class="comment"># 从此机器中删除所有镜像</span></span><br><span class="line">docker login             <span class="comment"># 使用您的 Docker 凭证登录此 CLI 会话</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># 标记 &lt;image&gt; 以上传到镜像库</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># 将已标记的镜像上传到镜像库</span></span><br><span class="line">docker <span class="keyword">run</span> username/repository:tag                   # 运行镜像库中的镜像</span><br><span class="line">docker stack ls              <span class="comment"># 列出此 Docker 主机上所有正在运行的应用</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># 运行指定的 Compose 文件</span></span><br><span class="line">docker stack services &lt;appname&gt;       <span class="comment"># 列出与应用关联的服务</span></span><br><span class="line">docker stack ps &lt;appname&gt;   <span class="comment"># 列出与应用关联的正在运行的容器</span></span><br><span class="line">docker stack rm &lt;appname&gt;                             <span class="comment"># 清除应用</span></span><br><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># 创建 VM（Mac、Win7、Linux）</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine <span class="keyword">env</span> myvm1                <span class="comment"># 查看有关节点的基本信息</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         <span class="comment"># 列出 swarm 中的节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        <span class="comment"># 检查节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   <span class="comment"># 查看加入令牌</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># 打开与 VM 的 SSH 会话；输入“exit”以结束会话</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  <span class="comment"># 使工作节点退出 swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> <span class="comment"># 使主节点退出，终止 swarm</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># 启动当前未运行的 VM</span></span><br><span class="line">docker-machine stop $(docker-machine ls -q)               <span class="comment"># 停止所有正在运行的 VM</span></span><br><span class="line">docker-machine rm $(docker-machine ls -q) <span class="comment"># 删除所有 VM 及其磁盘镜像</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~     <span class="comment"># 将文件复制到节点的主目录</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   <span class="comment"># 部署应用</span></span><br></pre></td></tr></table></figure><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;localfilename&gt; &lt;flename&gt; <span class="comment">#导出镜像到本地文件</span></span><br><span class="line">docker load --input &lt;filename&gt; <span class="comment">#从导出的本地文件中再导入到本地镜像库</span></span><br><span class="line">docker load &lt; &lt;filename&gt; <span class="comment">#同上，导入镜像以及其相关的元数据信息(包括标签等)(生成镜像文件)</span></span><br><span class="line">docker <span class="keyword">run</span> -d ... # 使docker容器在后台以守护态形式运行</span><br><span class="line">docker export &lt;container id&gt; &gt; &lt;localfilename&gt; <span class="comment"># 将本地的某个容器导出</span></span><br><span class="line">docker import - &lt;repository:tag&gt; <span class="comment"># 将容器快照文件导入为镜像 (生成镜像快照)</span></span><br><span class="line">docker load 和 docker import 的区别：</span><br><span class="line">  docker import 将丢弃所有的历史记录和元数据信息(仅保存容器当时的快照状态)，</span><br><span class="line">  docker load 将保存完整记录，体积较大</span><br><span class="line">  docker import 导入时可以重新指定标签等元数据信息</span><br><span class="line">docker image ls --digests <span class="comment"># 列出所有镜像的摘要</span></span><br><span class="line">docker image rm &lt;id、repository:tag&gt; <span class="comment"># 删除镜像，在通过id删除时，可以指定前3个字符以上，但是要能足够用于区分别的镜像</span></span><br><span class="line">docker image rm &lt;digest&gt; <span class="comment"># 精确删除</span></span><br></pre></td></tr></table></figure><p><em>Union FS 是有最大层数限制的,比如 AUFS，一个镜像不能超过127层</em></p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>仓库名、标签均为<code>&lt;none&gt;</code>的镜像，被称为虚悬镜像</p><p>显示虚悬镜像：<code>docker image ls -f dangling=true</code></p><p>删除虚悬镜像：<code>docker image prune</code></p><h2 id="docker-中的过滤器"><a href="#docker-中的过滤器" class="headerlink" title="docker 中的过滤器"></a>docker 中的过滤器</h2><p>在docker image ls还支持使用过滤器参数 –filter或-f</p><ul><li>since 在某个镜像之后建立的镜像</li><li>before在某个镜像之前建立的镜像</li><li>dangling未打开标签</li></ul><p>镜像是多层存储,每一层是在前一层的基础上进行的修改;而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。</p><p>镜像的定制实际上就是定制每一层所添加的配置、文件.</p><p>在构建Dockerfile时，如果使用了scratch为基础镜像，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始，这样减少了镜像体积。</p><h2 id="从标准输入中读取Dockerfile"><a href="#从标准输入中读取Dockerfile" class="headerlink" title="从标准输入中读取Dockerfile"></a>从标准输入中读取Dockerfile</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line">或</span><br><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为<code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，它没有上下文，因此不以像其他方法那样将文本文件<code>Copy</code>进镜像之类的事情</p><h2 id="ADD中更高级的复制文件"><a href="#ADD中更高级的复制文件" class="headerlink" title="ADD中更高级的复制文件"></a>ADD中更高级的复制文件</h2><p>ADD指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;</p><h2 id="COPY和ADD指令选择时遵循的原则"><a href="#COPY和ADD指令选择时遵循的原则" class="headerlink" title="COPY和ADD指令选择时遵循的原则"></a>COPY和ADD指令选择时遵循的原则</h2><p>所有文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD</p><p>Docker 不是虚拟机,容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,用upstart/systemd 去启动后台服务,容器内没有后台服务的概念。<br>启动程序就是容器应用进程,容器就是为了主进程而存在的,主进程退出,容器就失去了存在的意义。<br>当使用ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT。</p><p><code>EXPOSE</code>指令是声明运行时容器提供的服务端口</p><p><code>WORKDIR</code>可以来指定工作目录(或者称为当前目录)，以后各层的当前目录就被改为指定的目录，如果目录不存在，WORKDIR自动创建目录。</p><p><code>USER</code>和<code>WORKDIR</code>都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后层的执行<code>RUN</code>、<code>CMD</code>以及<code>ENTRYPOINT</code>这类命令的身份。</p><p><code>HEALTHCHECK</code>支持下列选项:</p><ul><li>–interval=&lt;间隔&gt; :两次健康检查的间隔,默认为 30 秒;</li><li>–timeout=&lt;时长&gt; :健康检查命令运行超时时间,如果超过这个时间,本次健康检查就被视为失败,默认 30 秒;</li><li>–retries=&lt;次数&gt; :当连续失败指定次数后,则将容器状态视为<em>unhealthy</em>,默认3次。</li></ul><p><em><code>CMD</code>、<code>ENTRYPOINT</code>、<code>HEALTHCHECK</code>三者的共同点：在Dockerfile文件中只可以出现一次，如果出现多次，只有最后一个生效。</em></p><h2 id="镜像迁移"><a href="#镜像迁移" class="headerlink" title="镜像迁移"></a>镜像迁移</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker export container_id &gt; export_filename.tar</span><br><span class="line"></span><br><span class="line">cat export_filename.tar | docker import - repository:tag</span><br></pre></td></tr></table></figure><p>此处利用了Linux中的管道，将一个镜像文件从一台机器迁移到另一台机器</p><h2 id="docker-attach和docker-exec的区别"><a href="#docker-attach和docker-exec的区别" class="headerlink" title="docker attach和docker exec的区别"></a>docker attach和docker exec的区别</h2><p>相同点：</p><ul><li>两者都可以使用-d、-i参数，在同时使用这两个参数时，都是进入bash</li><li>-i参数是没有分配伪终端，但命令执行结果仍然返回</li></ul><p>不同点：</p><ul><li>在使用attach进入伪终端，输入exit退出时，会导致容器的停止</li><li>exec进入终端，输入exit退出时，不会导致容器的停止</li></ul><h2 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container rm 容器名称</span><br><span class="line">docker container prune <span class="comment"># 清理所有处于终止状态的容器</span></span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器,可以添加-f参数。Docker 会发送SIGKILL信号给容器。</p><h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷(Volumes)</li><li>挂载主机目录(Bind mounts)</li></ul><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在同期之间共享和重用</li><li>对数据卷的修改会立即生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><h3 id="数据卷操作命令"><a href="#数据卷操作命令" class="headerlink" title="数据卷操作命令"></a>数据卷操作命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &lt;volumename&gt; # 创建一个数据卷</span><br><span class="line">docker volume ls # 查看所有数据卷</span><br><span class="line">docker inspect &lt;contrainer name&gt; # 查看容器的信息</span><br><span class="line">docker volume rm &lt;volumename&gt; # 删除数据卷</span><br></pre></td></tr></table></figure><p>在用docker run命令的时候，使用 –mount标记来将数据卷挂载到容器里，在一次docker run中可以挂载多个数据卷。</p><p>数据卷是被设计用来持久化数据的，它的声明周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收机制。</p><h3 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h3><p>在容器中运行一个网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来执行端口映射</p><p>在使用<code>-P</code>标记时，Docker会随机映射一个<code>49000~49900</code>的端口到内部容器开放的网络端口。</p><h2 id="Compose中的两个重要概念"><a href="#Compose中的两个重要概念" class="headerlink" title="Compose中的两个重要概念"></a>Compose中的两个重要概念</h2><ul><li>服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</li></ul><h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><p>命令选项</p><ul><li>-f, –file FILE 指定使用的 Compose 模板文件,默认为<code>docker-compose.yml</code>,可以多次指定。</li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li><li>–x-networking 使用Docker的可拔插网络后端特性</li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为<code>bridge</code></li><li>–verbose 输出更多调试信息</li><li>-v, –version打印版本并退出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-中的三个基本概念&quot;&gt;&lt;a href=&quot;#Docker-中的三个基本概念&quot; class=&quot;headerlink&quot; title=&quot;Docker 中的三个基本概念&quot;&gt;&lt;/a&gt;Docker 中的三个基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;镜像(Image)&lt;/l
      
    
    </summary>
    
      <category term="Docker" scheme="http://quiryrain.tk/categories/Docker/"/>
    
    
      <category term="学习总结" scheme="http://quiryrain.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="Docker" scheme="http://quiryrain.tk/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python3爬虫之urllib模块</title>
    <link href="http://quiryrain.tk/190502/"/>
    <id>http://quiryrain.tk/190502/</id>
    <published>2019-05-02T02:45:54.000Z</published>
    <updated>2019-06-15T03:05:48.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python2-中的urllib和Python3中的urlllib的区别"><a href="#Python2-中的urllib和Python3中的urlllib的区别" class="headerlink" title="Python2 中的urllib和Python3中的urlllib的区别"></a>Python2 中的urllib和Python3中的urlllib的区别</h3><p>在python 2中有urllib和urllib2两个库进行实现请求的发送，但是再python 3中官方将urllib2库合并在了urllib库中。所以在3中使用urllib库时一定要先了解其中的四个模块：</p><ul><li>request：这个模块是最基本的HTTP请求模块，用来模拟发送请求。</li><li>error：异常处理模块，用来捕获异常，保证程序不会意外终止。</li><li>parse：工具模块，提供了许多URL处理方法，如拆分、解析、编码等</li><li>robotparser:用来识别网站的robots.txt文件，判断哪些网站可以爬，一般不用。<br>此处只讲解前三个的用法。</li></ul><h3 id="请求的发送"><a href="#请求的发送" class="headerlink" title="请求的发送"></a>请求的发送</h3><p>1、urlopen()函数<br>在urllib.request模块中提供了最基本的构造HTTP请求的方法，可以利用它进行模拟浏览器发送一个请求，同时它还具有处理授权验证、重定向、浏览器cookies等其他内容<br>下面以百度为例子，进行网页的抓取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request.urlopen(&apos;http://www.baidu.com&apos;)</span><br><span class="line">print(response.read().decode(&apos;utf8&apos;))</span><br></pre></td></tr></table></figure></p><p>可以很简单的看出，上面很简单的三行代码已经实现了一个简单的爬虫了。只不过这个爬虫获取下来的内容没有经过任何数据处理，我们可以很容的看到百度首页的源代码。<br>之后，查看返回的内容是什么类型的。<br><code>print(type(response))</code><br>输出为：<code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code><br>可以发现，它是一个HTTPResponse类型的对象，接下来查看有那些函数和属性，使用<code>dir(response)</code>：<br>输出为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;__abstractmethods__&apos;, &apos;__class__&apos;, &apos;__del__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__eq__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__next__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;_abc_impl&apos;, &apos;_checkClosed&apos;, &apos;_checkReadable&apos;, &apos;_checkSeekable&apos;, &apos;_checkWritable&apos;, &apos;_check_close&apos;, &apos;_close_conn&apos;, &apos;_get_chunk_left&apos;, &apos;_method&apos;, &apos;_peek_chunked&apos;, &apos;_read1_chunked&apos;, &apos;_read_and_discard_trailer&apos;, &apos;_read_next_chunk_size&apos;, &apos;_read_status&apos;, &apos;_readall_chunked&apos;, &apos;_readinto_chunked&apos;, &apos;_safe_read&apos;, &apos;_safe_readinto&apos;, &apos;begin&apos;, &apos;chunk_left&apos;, &apos;chunked&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;code&apos;, &apos;debuglevel&apos;, &apos;detach&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;fp&apos;, &apos;getcode&apos;, &apos;getheader&apos;, &apos;getheaders&apos;, &apos;geturl&apos;, &apos;headers&apos;, &apos;info&apos;, &apos;isatty&apos;, &apos;isclosed&apos;, &apos;length&apos;, &apos;msg&apos;, &apos;peek&apos;, &apos;read&apos;, &apos;read1&apos;, &apos;readable&apos;, &apos;readinto&apos;, &apos;readinto1&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;reason&apos;, &apos;seek&apos;, &apos;seekable&apos;, &apos;status&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;url&apos;, &apos;version&apos;, &apos;will_close&apos;, &apos;writable&apos;, &apos;write&apos;, &apos;writelines&apos;]</span><br></pre></td></tr></table></figure></p><p>其中最主要函数为：read()、readinto()、getheader(name)、getheaders()、fileno()等方法。<br>在调用read()方法时可以返回网页内容，使用status属性可以查看返回的状态码。<br>在urlopen()方法中，最基本的是简单网页的GET请求抓取。但是如果要传入一个参数呢？下面就讲解参数的使用方法。  </p><ol><li>data参数<br>在讲解之前，首先需要说明的是data参数是可选的，如果传入了此参数，要以字节流编码格式的内容，即bytes类型，需要进行转化。此时的请求方式不再是GET方法，而是POST方法.因为如果使用GET方法，会将传入data暴露在url中，十分不安全。<br>实例一:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">data = bytes(parse.urlencode(&#123;&apos;word&apos;: &apos;hello world&apos;&#125;), encoding=&apos;utf8&apos;)</span><br><span class="line">response = request.urlopen(&apos;http://httpbin.org/post&apos;, data=data)</span><br><span class="line">print(response.read().decode(&apos;utf8&apos;))</span><br></pre></td></tr></table></figure></li></ol><p>这里我们传入了一个参数word，值为hello world。由于发送的的data需要是字节流类型，此处使用到了上文提到的工具包函数parse，使用它将我们要传入的函数进行转码。在我们执行完这段代码后，服务器会给我们返回一下结果:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;word&quot;: &quot;hello world&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们可以很容易的看到，在返回的结果中有form字段，字段中的内容就是我们传入的data中的内容，至此我们已经模拟了表单提交的过程，以POST请求方式尽心传输数据。  </p><ol start="2"><li>timeout参数<br>顾名思义，这个参数就是用来设置超时的。单位为秒，意思是当请求超出了设置的值后还有得到响应，就讲异常抛出。如果此参数不指定时间，使用全局默认时间。<br>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)</span><br><span class="line">print(response .read().decode(&apos;utf8&apos;))</span><br></pre></td></tr></table></figure></li></ol><p>运行结果：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test_urllib_001.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    response = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 222, in urlopen</span><br><span class="line">    return opener.open(url, data, timeout)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 525, in open</span><br><span class="line">    response = self._open(req, data)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 543, in _open</span><br><span class="line">    &apos;_open&apos;, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 503, in _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1345, in http_open</span><br><span class="line">    return self.do_open(http.client.HTTPConnection, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1319, in do_open</span><br><span class="line">    raise URLError(err)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error timed out&gt;</span><br></pre></td></tr></table></figure></p><p>这里我们设置了超时的时间是0.1秒。程序再执行0.1秒以后，服务器依然没有任何响应，于是抛出了URLError异常。可以从<code>&lt;urlopen error timed out&gt;</code>看出是网络超时。那么问题来了，如何抓取这种情况呢？<br>实例：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request .urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    if isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(&apos;Time Out&apos;)</span><br></pre></td></tr></table></figure></p><p>我们用try: … except: …来捕获异常，此处引入了socket模块。  </p><p>2、Request<br>到此，我们知道了如何用urlopen方法实现一个简单的请求发送。但是这些简单参数有时候并不能满足我们的需求，比如我们需要在请求中添加header，此时就需要一个更加强大的类来实现了，这就是本节要讲的Request类。<br>实例是最好的验证。<br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">req = request.Request(&apos;https://baidu.com&apos;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>此处我们依然使用了上文的urlopen()方法，只是此时的参数不再是一个URL了，而是一个Request对象。另外，这个函数我们可以很灵活的配置我们需要的参数。看下它的构造方法吧：<br><code>urllib.request.Request(url, data=None, headers={},origin_req_host=None, unverifiable=False,method=None)</code><br>  解释下：</p><ul><li>url：请求的URL，必填项</li><li>data：字节流，请求时需要带的数据</li><li>header：请求头，在创建实例后可以通过add_header()添加</li><li>origin_req_host: 请求方的host名称或IP地址</li><li>unverifiable：表示请求是否无法是验证的，默认为False。意思是用户没有足够的权限来选择接收这个请求的结果。</li><li>method：请求是用的方法，如GET、POST等</li></ul><p>下面实现一个多参数构建请求的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">url = &apos;http://httpbin.org/post&apos;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&apos;</span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    &apos;name&apos;: &quot;spider_road&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data= bytes(parse.urlencode(dict), encoding=&apos;utf8&apos;)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method =&apos;POST&apos;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&apos;utf8&apos;))</span><br></pre></td></tr></table></figure></p><p>我们通过四个参数四个参数构建了这个请求，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;spider_road&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>在上节中，我们简单的提到了如何对异常做出处理，但是程序在运行过程总会出现一些其他的错误，当出现这些错误时，异常处理还是很有必要做的。<br>1、URLError<br>URLError类来自于urllib库的error模块，继承自OSError类，由request模块产生的异常都已使用这个类来捕捉。<br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&apos;https://spider-road.com&apos;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure></p><p>上面的程序我们使用它打开了一个不存在的网址，我们使用try:… except:…来捕获了异常。<br>运行输出：<code>[Errno -2] Name or service not known</code>，此时有效得避免了程序异常终止。</p><p>2、HTTPError<br>它是URLError的子类，用来处理HTTP请求错误，比如认证请求失败等。它有一下3个属性：</p><ul><li>code： http状态码</li><li>reason：错误原因</li><li>headers： 返回请求头</li></ul><p>实例验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&apos;https://spider-road.com&apos;)</span><br><span class="line">except error.HTTPError as e:</span><br><span class="line">    print(f&apos;code:&#123;e.code&#125;\nreason:&#123;e.reason&#125;\nheaders:&#123;e.headers&#125;&apos;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure></p><p>由于没有该网站，所以最后返回的是：<code>[Errno 110] Connection timed out</code><br>至此，关于urllib请求和错误处理已经讲解完毕，后续还有关于此节更为高级的用法。欢迎订阅爬虫之道，我们在这里等待你的到来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python2-中的urllib和Python3中的urlllib的区别&quot;&gt;&lt;a href=&quot;#Python2-中的urllib和Python3中的urlllib的区别&quot; class=&quot;headerlink&quot; title=&quot;Python2 中的urllib和Pyt
      
    
    </summary>
    
      <category term="Python后端" scheme="http://quiryrain.tk/categories/Python%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="爬虫" scheme="http://quiryrain.tk/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="urllib" scheme="http://quiryrain.tk/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>在Centos中架设ss服务</title>
    <link href="http://quiryrain.tk/190425/"/>
    <id>http://quiryrain.tk/190425/</id>
    <published>2019-04-25T03:05:00.000Z</published>
    <updated>2019-06-15T03:05:48.822Z</updated>
    
    <content type="html"><![CDATA[<p>想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。</p><h3 id="Google访问助手"><a href="#Google访问助手" class="headerlink" title="Google访问助手"></a>Google访问助手</h3><p>如果你使用的是这种方式，那么恭喜你，下面介绍的内容和你无关了。</p><p>Google访问助手下载链接：<a href="http://ggfwzs.com/" target="_blank" rel="noopener">链接</a></p><h3 id="架设SS服务"><a href="#架设SS服务" class="headerlink" title="架设SS服务"></a>架设SS服务</h3><p>架设环境</p><ul><li>一台可以访问外网的VPS服务器</li><li>Centos7 + Python2.x</li></ul><p>架设步骤</p><ul><li>安装必须的软件包:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum upgrade -y</span><br><span class="line">yum groupinstall &quot;Development Tools&quot;</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install python-setuptools python-pip m2crypto -y</span><br><span class="line"></span><br><span class="line">## 更新pip包</span><br><span class="line">python -m pip install -U pip</span><br><span class="line"></span><br><span class="line">## 安装shadowsocks</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><ul><li><p>创建配置文件</p><p>以下内容是创建唯一密码和端口的配置文件，如果多用户使用，建议直接使用多用户配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">### 单用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">  &quot;server_port&quot;:server_port,    #例如5460</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">  &quot;timeout&quot;:600,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 多用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;your_server_ip&quot;, # 或者使用 0.0.0.0</span><br><span class="line">  &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;port_password&quot;:&#123;   #端口号与密码</span><br><span class="line">    &quot;8989&quot;:&quot;password0&quot;,   # 左边是端口号，右边是密码</span><br><span class="line">    &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">    &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">    &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">    &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;timeout&quot;:300,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">第二种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timeout&quot;: 600,</span><br><span class="line">  &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;port_password&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;password1&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;password2&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;password3&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_comment&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;xiaoming&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;lilei&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;mike&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>系统级服务关闭</p><p>在配置完成后，需要关闭防火墙，否者会造成无法科学上网。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop iptables</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>若配置完成，且防火墙关闭，依旧无法科学上网，那么看是否是浏览器设置问题，若浏览器有FQ插件且处于启用状态（浏览器启用代理），停用它。</p></li><li><p>测试是否可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 开启ss服务</span><br><span class="line">ssserver -c /etc/shadowsocks.json start</span><br></pre></td></tr></table></figure><p>如果可以使用，则说明配置完成</p></li><li><p>将SS服务变为系统级服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/shadowsocks.service</span><br><span class="line"></span><br><span class="line">### 将以下内容粘贴到打开的shadowsocks.service文件中</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable shadowsocks &amp;&amp; systemctl start shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>为OpenVZ的VPS服务器做BBR加速</p><p>本安装<strong>适用于CentOS/RHEL7+，Ubuntu15+，Debian8+</strong> 的64位系统，如不是请先重装系统，下载rintd二进制文件(原版bbr和修改版bbr二选一即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd_bbr_powered -O /root/rinetd</span><br></pre></td></tr></table></figure><p>最后一个为魔改版BBR，上面一个为原版。选一个下载就可以了。然后修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x rinetd</span><br></pre></td></tr></table></figure><p>修改rinetd的配置文件rinetd.conf,添加监听地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim rinetd.conf</span><br><span class="line"></span><br><span class="line"># bindadress bindport connectaddress connectport </span><br><span class="line">0.0.0.0 443 0.0.0.0 443</span><br><span class="line"></span><br><span class="line">0.0.0.0 80 0.0.0.0 80</span><br></pre></td></tr></table></figure><p>每一行都是一个端口，将端口改成你使用的端口就可以了。不要问我一行为什么要写两个相同的，我也不知道为什么。</p></li><li><p>将rinetd变为系统级应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/rinetd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=rinetd</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/rinetd -f -c /root/rinetd.conf raw venet0:0</span><br><span class="line">Restart=always</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rinetd &amp;&amp; systemctl start rinetd</span><br></pre></td></tr></table></figure><p>在以上操作完毕后，OpenVZ架构的VPS服务器在使用SS服务时，会明显感觉到访问速度快了很多。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。&lt;/p&gt;
&lt;h3 id=&quot;Google访问助手&quot;&gt;&lt;a href=&quot;#Google访问助手&quot; class=&quot;headerlink&quot; title=&quot;Google访问助手&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="科学上网" scheme="http://quiryrain.tk/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="ss" scheme="http://quiryrain.tk/tags/ss/"/>
    
      <category term="科学上网" scheme="http://quiryrain.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows10中Tensorflow GPU的安装</title>
    <link href="http://quiryrain.tk/190418/"/>
    <id>http://quiryrain.tk/190418/</id>
    <published>2019-04-18T00:27:27.000Z</published>
    <updated>2019-06-15T03:05:48.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tensorflow介绍"><a href="#Tensorflow介绍" class="headerlink" title="Tensorflow介绍"></a>Tensorflow介绍</h3><blockquote><p>TensorFlow™是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</p></blockquote><h3 id="Tensorflow2-0-GPU版的安装"><a href="#Tensorflow2-0-GPU版的安装" class="headerlink" title="Tensorflow2.0 GPU版的安装"></a>Tensorflow2.0 GPU版的安装</h3><p>首先，先确定你要安装的是Tensorflow的CPU版还是GPU版。如果是CPU，请出门右转（开个玩笑）。</p><p>其次，Tensorflow分为1.x版本和2.x版本。在本文写的时候，Tensorflow刚出到2.0（preview）版本。对于本文而言，均采用pip的方式安装Tensorflow，并没有采用源码编译的方式。</p><p>如果你在pip安装的时候下载很慢，建议你pip使用<a href="https://opsx.alibaba.com/mirror?lang=zh-CN" target="_blank" rel="noopener">阿里开源镜像</a>源。具体配置方法为：</p><p>在阿里开源镜像中找到<code>pypi</code>，然后点击帮助。  </p><p>打开<code>C:\User\XXX</code>，然后在其中创建pip文件夹，打开刚创建的pip文件夹，在其中创建<code>pip.ini</code>文件。最后将下方代码粘贴进去即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>现在开始介绍Tensorflow的安装</p><ul><li><p>CPU版的安装</p><blockquote><p>如果你想安装的是Tensorflow1.x的版本，请使用<code>pip install tensorflow</code></p><p>如果是Tensorflow 2.x的版本，请使用`pip install tensorflow==2.0.0-alpha0</p></blockquote></li></ul><p>Tensorflow GPU安装时的准备工作：</p><p>在安装以下两个文件之前，先去<a href="https://tensorflow.google.cn/install/gpu" target="_blank" rel="noopener">Tensorflow官网</a>查看GPU安装时对CUDA和cudnn的版本要求，特别要注意标红部分。</p><p><img src="/userImages/GPU_cuda_install.png" alt></p><ul><li><p>CUDA的下载与安装</p><p>下载网址:<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></p><p><img src="/userImages/cuda_download_1.png" alt></p><p>如果当前的CUDA Toolkit版本比较高，需要选择低版本的CUDA Toolkit，请点击<em>Legacy Releases</em>之后选择Tensorflow官网要求的版本。</p><p><img src="/userImages/cuda_download_2.png" alt></p><p><img src="/userImages/cuda_download_3.png" alt></p><p>最后等待下载完毕。</p><p><img src="/userImages/cuda_install_1.png" alt></p><p><img src="/userImages/cuda_install_2.png" alt></p><p>要特别主要自定义中的内容。</p><ul><li><p>CUDA中的内容选择</p><p>如果你不使用<code>Visual Studio</code>请把前面个方框中的<code>√</code>去掉。</p></li><li><p>NVIDIA GeForce Experience</p><p>可选可不选</p></li><li><p>Driver components</p><p>如果你<code>当前版本</code>高于或等于上面的<code>新版本</code>,那么此选项不选，如果你<code>当前版本</code>低于<code>新版本</code>，请选择。</p></li><li><p>Other components</p><p>可选可不选</p></li></ul><p><img src="/userImages/cuda_install_3.png" alt></p><p><img src="/userImages/cuda_install_4.png" alt></p><p><img src="/userImages/cuda_install_5.png" alt></p><p>最后直接点击<code>下一步</code>即可。</p></li><li><p>cudnn的下载与安装</p><p>cudnn的下载是需要登录的。</p><p>下载网址:<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p><p><img src="/userImages/cudnn_download_1.png" alt></p><p>在下载cudnn的时候，要特别注意cudnn对应的cuda版本号，cuda的版本要使用Tensorflow官网要求的版本号，否者会无法使用GPU版的。注意标红的第二部分。</p><p><img src="/userImages/cudnn_download_2.png" alt></p><p>然后点击<code>Windows 10</code>即可下载。</p><p>在将cudnn下载完毕后，cudnn不是安装程序，将其解压即可，然后将文件夹名改为<code>cudnn</code>，最后将该文件夹移动到<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code>中即可。</p></li><li><p>环境变量的配置</p><p>将以下两个路径添加进系统的环境变量中，最后将刚才添加的环境变量移动到最上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\libx64</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\cudnn\bin</span><br></pre></td></tr></table></figure><p><img src="/userImages/cuda_and_cudnn.png" alt></p></li><li><p>验证是否可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.test.is_gpu_available()</span><br></pre></td></tr></table></figure><p><img src="/userImages/cuda_and_cudnn_1.png" alt></p><p>通过以上程序，如果没有出错，则说明安装成功，如果出错，请仔细阅读以上内容。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tensorflow介绍&quot;&gt;&lt;a href=&quot;#Tensorflow介绍&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow介绍&quot;&gt;&lt;/a&gt;Tensorflow介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TensorFlow™是一个采用数
      
    
    </summary>
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/categories/Tensorflow/"/>
    
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/tags/Tensorflow/"/>
    
      <category term="GPU" scheme="http://quiryrain.tk/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow知识总结</title>
    <link href="http://quiryrain.tk/190416-1/"/>
    <id>http://quiryrain.tk/190416-1/</id>
    <published>2019-04-16T02:30:52.000Z</published>
    <updated>2019-06-15T03:05:48.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消除过拟合的方法"><a href="#消除过拟合的方法" class="headerlink" title="消除过拟合的方法"></a>消除过拟合的方法</h3><ul><li>L1正则化   绝对值</li><li>L2正则化  平方</li><li>L3正则化  立方</li><li>L4正则化  4次方</li><li>dropout</li></ul><p>其中对图像的处理过程一般为:<br>输入 – &gt; 卷积 – &gt; 池化 –&gt; 卷积 –&gt; 池化 –&gt; 消除过拟合 –&gt;全连接层 – &gt; 全连接层 –&gt; 分类</p><p>max_pool函数的作用是降低系统的复杂度，其中pooling分为最大池化和平均值池化</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归的目标是找到一个与训练数据最为吻合的线性函数。对于2D数据是找到一个与数据相吻合的线性函数<br>线性回归是一种找到最适合一组点的直线或超平面的方法</p><p>在卷积运算中，对图像降维是通过修改卷积核的strides（步长）参数进行降维的。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>单层CNN的实际用途是检测边缘。对于图像识别和分类任务而言，更常见的情形是使用不同的层类型支持某个卷积层。这些层有助于减少过拟合，并可加速训练过程和降低内存占用率。</p><p>tf.nn.depthwise_conv2d:将一个卷积层的输出连接到另一个卷积层的输入<br>tf.nn.separabel_conv2d:对于较大的模型，可保证在不牺牲准确率的前提下实现训练的加速。对于较小的模型，它能够快速收敛，但准确率较低。<br>tf.nn.conv2d_transpose:将一个卷积核应用于一个新的特征图，后者的每一部分都填充了与卷积核相同的值。当该卷积核遍历新图像时，任何重叠的部分都相加在一起。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>为神经网络引入非线性</p><p>在CNN中最常用的激活函数：<br>tf.nn.relu:<br>Relu是分段线性的。当输入为非负数时，输出与输入相同。当输入为负数时，输出均为0.<br>优点：不受梯度消失的影响，取值范围为[0,++]<br>缺点：当使用较大的学习速率时，易受达到饱和的神经元的影响。</p><p>tf.sigmoid:<br>sigmoid函数的返回值位于区间[0.0, 1.0]中。当输入值较大时，tf.sigmoid将返回一个接近于1.0的值，而输入值较小时，返回值将接近于0.0</p><p>tf.tanh:<br>双曲正切函数(tanh)与tf.sigmoid非常接近，且后者具有类似的优缺点。tf.tanh函数的值域为[-1.0, 1.0]</p><p>tf.nn.dropout:<br>依据某个可配置的概率将输出设为0.0.为学习到的输出添加少量噪声。</p><p>梯度是偏导数的矢量<br>Pandas 是用于进行数据分析和建模的重要库</p><ul><li>张量(Tensor)：是对高维数据的一种抽象式表达<br> Tensorflow张量是什么？</li><li>张量时用来表示多维数据的</li><li>张量时执行操作时的输入或输出数据</li><li>用户通过执行操作来创建或计算张量</li><li>张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得出。</li></ul><p>会话是什么?<br>会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。</p><p>会话执行:</p><ul><li>估算张量(Tensor.eval)</li><li>执行操作(Operation.run)</li><li>会话执行(Session.run)</li></ul><p>会话执行原理：<br>调用sess.run(tain_op)语句执行训练操作时：</p><ul><li>首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成了一副子图</li><li>然后，程序将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类。相同设备上的节点组成了一副局部图</li><li>最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序的加载到设备上执行。</li></ul><p>优化算法：<br>典型的机器学习和深度学习问题通常都需要转换为最优化问题进行求解。</p><p>求解最优化的问题的算法成为优化算法，他们通常采用迭代方式实现：首先设定一个初始的可行解。然后基于特定的函数反复重新计算可行解，直到找到一个最优解或达到预设的收敛条件。</p><p>不同的优化算法采用的迭代策略各有不同：</p><ul><li>有的使用目标函数的一阶导数，如梯度下降法</li><li>二阶导数，如牛顿法</li><li>前几轮迭代的信息，如Adam</li></ul><p>优化器是实现优化算法的载体：<br>一次典型的迭代优化应该分为以下3个步骤：</p><ul><li>计算梯度： 调用compute_gradients方法</li><li>处理梯度： 用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等</li><li>应用梯度： 调用apply_grandients方法，将处理后的梯度值应用到模型参数  </li></ul><p>Loss下降方法：</p><ul><li><p>随机梯度下降</p></li><li><p>最速下降法: tf.train.AdamOptimizer()</p></li></ul><p>监督学习典型算法:</p><ul><li>线性回归（Linear Regression）</li><li>逻辑回归（Logistic Regression）</li><li>决策树（Decision Tree）</li><li>随机森林（Random Forest）</li><li>最紧邻算法（k-NN）</li><li>朴素贝叶斯（Naice Bayes）</li><li>支持向量机（SVM）</li><li>感知器（Perceptron）</li><li>深度神经网络（DNN）</li></ul><p>Tensorflow训练模型的工作流</p><blockquote><p>数据读入–&gt; 数据分析 –&gt; 数据规范化 –&gt; 创建模型 –&gt; 创建会话 –&gt; 训练模型</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消除过拟合的方法&quot;&gt;&lt;a href=&quot;#消除过拟合的方法&quot; class=&quot;headerlink&quot; title=&quot;消除过拟合的方法&quot;&gt;&lt;/a&gt;消除过拟合的方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;L1正则化   绝对值&lt;/li&gt;
&lt;li&gt;L2正则化  平方&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/categories/Tensorflow/"/>
    
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/tags/Tensorflow/"/>
    
      <category term="学习总结" scheme="http://quiryrain.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow的基础学习和资料</title>
    <link href="http://quiryrain.tk/190416/"/>
    <id>http://quiryrain.tk/190416/</id>
    <published>2019-04-16T00:44:34.000Z</published>
    <updated>2019-06-15T03:05:48.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="以下内容为测试内容"><a href="#以下内容为测试内容" class="headerlink" title="以下内容为测试内容"></a>以下内容为测试内容</h3><blockquote><p>以下内容未测试内容</p></blockquote><p>中文测试</p><p>再次测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h3&gt;&lt;h3 id=&quot;以下内容为测试内容&quot;&gt;&lt;a href=&quot;#以下内容为测试内容&quot; class=&quot;headerlink&quot; title=&quot;以下内容为测试
      
    
    </summary>
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/categories/Tensorflow/"/>
    
    
      <category term="Tensorflow" scheme="http://quiryrain.tk/tags/Tensorflow/"/>
    
      <category term="机器学习" scheme="http://quiryrain.tk/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="资料" scheme="http://quiryrain.tk/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>有些人走着走着就散了</title>
    <link href="http://quiryrain.tk/181118/"/>
    <id>http://quiryrain.tk/181118/</id>
    <published>2019-03-01T01:41:48.000Z</published>
    <updated>2019-03-05T13:32:48.675Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX19mQXYJZTf2sfvRZgasasmv85ST1lpLVfnAtf8yjAM4w7Xo+HrPPiNKv/fC48bcS0sFRbc7VO7JfC1Rsif2tL6euK2bdaeYmXcWxno0r4OUgKO7IuSZe/qLn8HWZELBV9G9v+gTiPKN3dCflfI6ETk6Y+z3kYUBgY7IyYS8vNUjobCm3fTLLeI7RpggkKC/ZY3bzvldgvw1qb/4Bx3b+tPDBMFLD4VTMfefWNhTd42m6v5T388oXxvnYN7eNvaZjjo+kRSm5bX9F9nRyC/2YFAtg3stZhIVjtYq+WMyQf/cta4H4kjYUqX3Qd/dCffYH+9G2AQXCT1SacR9FDKSQTDWtJ++2Dwvy4Uqna8riajJOvSX10xRY9AIi6dSwegDjCMF5O50jl+BH0aeeCxdxOC9pwO8luhnFcCxEpKbFwgXrQkpSFtN5QbRpQ62rhLywvBtBkmkm9QwCbIEI6LQk0F02xXiSfun1NosF42iKe2CuWQpLR9g9alWdBCGeI0aAANJ5jbiFSLm3PebnXapIHolOVHZtWk0M6DEN/8K8sPPmJ/h0HPLCreSTIjgqkrnzoU5O0I4b22BZBId9ZzhRcr4O0kBJBSTzKBaVD3FOgHvCDRz4PkepTo2I85Z/80dmosJz7MMO3dxcPVnIO+TDoAcQaEQXE6bQFr6Yt1z/coWu8ulKzA7zJV8Ux7zIwoOQLUKrwVUzzVBgIqhmMfcAd2AoM/l+ycnxWL2BV9dRCJS60q9RxtJ42kl/0YYOfNHGDMdvO7W82h3icTMz2TDLiNRFEV6jQbNMmOR5Mi+1dLISvj59Br+QRt8DBdH/GYgRNnS+txceAj2rk9pK46aP74+Z+mVX4hU9EGeAos2Wbmc6VUxhx37fM/M6FEpdT2AKVsOkMsJXKR2Slnzpxwq2mzUbTlQLSWYEsvPtQ26AqsPPTKZ17iHnfPJTG879MHRW13HDeX03mSZ3G3+R7tX2S7GqJPeF2p0pGpqXykqciHuCZK1XRU7N2/33wyLBHbjJEKkOGHT/K2sqwmEjyT6R342IPvoivQuyxnKmKp4DG8HRSDitC8WLoyAXOX2zs5Oqy2/ZaKG0PCGnMZHR258W4Cevp6QvETJ8dhNJ1oJrEKxzjubpKjxdnAvhQvrrVtSpQoW/1MpkI8M4AKCb9D+v1I1gGcNT1drPp6uYFhy5AfQDFBeOtYojFdbhtDxcVwnpDxm1pBXwGw68Q4KWezM5fEU3Fyq/gBgkCEbtZ+ZZ5uJXWpsRYpl9tosSAe5rSwLd6GEtA9s0G5UHMKTOtHQNc4hfVqVMDiiMNNODIQ/O6bvyKyDr8/0P2WxCpIPgwSJPAT0x9lS+ey92sUtSecISs5tcFF7PrplseDdIgHPR/2N/2bea837rFiU5WpLa6mSC9ft1A1FId1E1hbmb1M+WzVpcI5d2Cwr98E90pgT6CX0icwrgu6Q5+PTEzBtIwmtdiz9ZRLdIGJ82sIQTgI3R5pOQfCti7aLfStnPN61it73eZUeLFi1AWHjOuKImBo2ensPd9kf7riHR1S9SH+O9E+eX+5clM+ExTwGYrJTbbSGcIV15NM742ECLPT3glgVHsapQHRN/5EEicaLUS2E03LQwe7VICeEunctjVAjEu/4g1VugxsqycAS8KslFsX8AMdcfI4l3fMps7CWZN7vFcSPawlsSSvy51IxepXHHcBl4nlc2USXIY7SqD//tb/ULjxZL+ExIt3P1DYRXLEaosARNyVYgyXSvPxtiMEc/AH8HhQveyE9jKNZ9sr3pObpNjFQPTUcuN5ioTkgU7xnjuCwYjN40vU+AsGf9wq/xZiJsqD8TH/Fh6YNOYdPEH8Ry8epQmZEsAQmaUlTLzLZwfD4TKDrqsw915gkBW2XCU7RdE2sAp/AckrACF0wuanWUxkSvt78TLADoQA6Pi9/6Ayukmy8MRbvB2ww3C9K/mhXh4Pjg+MiCUue+k3/1fHe5SH+x6fpkVDxm3oguKHek9qkLq3S3nNgwKyxNwj1SdVLp31RudQdfG7+3ef+2C2jld592RbWY+QaW6DVXwm8NdJcV19QjwF+JOxb6KScie29ygsTzCaSGNaNHeSYjySalG26LqqhOyu9F3YkQzW4nzXeCbrVsgxQLj7YVeZOklUHoDqLf3Ml1jSGeggnTWC11VuaNYAPe4ITRSH1yOjuQ8gVmmsiKp/N+HEhLTdGiLV/F7k7WhIy/Jhn1ntgbLcJZaplTeztMcRK7FUe8EAkhbHAnFO2HfAb7pKw/jTLCFBY9ssEoirqmy8h6flmWnHHPxWcn//ViOq2ea4ihT9uC1/urDZApUq3eLkUDsKNQ4jVudlcAi3sIQ/LT+IJ0yXT1Al3QnV2VQQQvrtJnBgoUY553qYg2FKV3aTZtYbM8pGImpwfPxqScfIBEWL3+r1H6clThkAasd2ix7otqfMeFY/nnJjBWVihNIqeU0YADuEumqJOxUMDDlSNmlyN1zN9NFfORY73IgY2ZOXlsD1FDpmMbY2hDsi32a5anBpbRNhyBg7+2ooX6G+p665N92kit4qEMh9mYSM/TCqWboPLbozEnIkWts8nxPBWonPPIIU05NpWQ0kaQvv+ut0radmfPON1pSOOASgp8XOaTWtfvJ8bu4KfyDCL11ejY9k1oGZP2AWiomAFqbyjsr0hQiWitGseV4ngjo2UQlCBe2I8C5QrYenKWUOPj71USbU7MRiOYIcSrKAMCxwt+268MAEmyVJUj5gqUoGfPLTgWCLMr/D8yqNiDB/mbY5+A6B53/b0D0UMWcq0yvINp4F55saNybYCz2WhLYE5UZ5KpBOflwEexMGsXAxGIUQeyNEz+GklvBH/EjdN/S+XhplEV5BQiPUYopqJGa39qv1+wiHMol6cAoOr5FvPKa50FmXz6llOlwxqEPsg8p5RKeLZhGWWMfOxDYMcj2iim9F7e/ZZs5m9LPr7TYygoit0rzq1FLZPRg6Gw8GHwl9l6mPqtZkh2kur3VUFnfiOAr1dEACFy0iBSAJfSjT2kTEGZVR8kHVpfuiMAOIYWuyMnI7msC82JwuAbt3WoUoHfFYcqd5bI2l+NS3V4LUctZAF3sUPQZoEcx9qKmTtx20zUV+/DwGACy1zJE12JRk5heRYsn5oejSlOFJW2qrdbPAXylzzL+uX9TBfXQscddUmZ2Qx6Jl4EOl1qSw2lLnX53TDf+dvhcr0j5oCVgMZBPgo1QKkz8dFCWWqDR+mTAJso1SplBqyCfYlxmMZCm5KLT/niG3I+EC9ylGVnD3CTIOHuMkdsTmh6ATazBGC/WoXpFyxhCBfpbeM+HePYwMKWU/QKXF+6ruwuR7iU0Y2e1wZ70ZMxF6G1B1dS4LkkHUiwRrJnUcWLHq0nEdQA1Dsk0liwPlWKCUoVqg0XbFDAfe6KMieR0WTiMpzaRDbRh4GH/9m7KRYJrRVaM/KMdlxg4J3L/D1wRnzxBanfYrP+MItxm2YVS5b4wpAYouAiH0Rhhi8ju5AYqW1FZ0ouLwjzn+AcHLUBrokUkt/al87/n7BN5Y1BHzyOQbHW8gDCv0lY3+7N8PXZOfiU4KoxOe6wQlDi8ZFVNM9DLOHzv690i8f/IH0IPYDZWdhEMLsVJzf566Qf23jHqODSs5SXIETpdQjDhyJp6EOpRY8MSDwRnIAU9N3lP37soINY8a5ZMdWPseWYKhO/VcEbm3x5Gz27DUx+zEFuuqn0JTKRmIWYuhdNr8TwcXcDjpcaRqDHJaGUafa78WAqcMShaEzj9x7p/99R//tKvDgo4KsYfOkzaLKLTamjZ2XlDDnqdDuHWYpdDpcihsCNLUQanTXypjSHpBNsgryHOLa8Afli/UAGSVWk4syN25qez7gBSyuH3XSr6kpEQz8jWtUY7X/lS32FAsh3UJltkPLoEPZJZPDgU0wulNmAE1rUTRYTdLf+daNte0G5f26AIXQR/Mprm7z9xyUhyRWuyQFZnwu6FPLz+e9b75Wd/VabJxclNVHbkCmOZVYOH2M6U6lkuiX7kNV8QC9thNgLg+jVk617WOx7xc8I3CGAetmLBlsacczwgL6sxvFDu+zfn4CaxQFNwhp8L9trUcJnWi4cYsBFQgxSbJHrkpJTk+aHoU+qC2+vEQ5inFUO1gsAkJK4z3/jDRvU/mxP06Jq9+pukOpHxgVrHRrtIHNBnhyQnc3CRPiibtHmlIb4PZagv472xCthFhKIjQMMeC4f/kZbMCjsaOTNhbTKybGEdella/S3U2YCc844UYBs1S+w6TCa9cICgQ8hWRDkq5gVxIaj/fxkBFmI9ts4XUiBbGNKRugZZqRagYtcmgKJoFAH0naN78C3G/EnhRqjveN4m61iL1TR2AU2C4AW3LHOS4x1T2Wukc8Y4R9e4aoVTmKmhz6scp//zkHWO4A2joHSFqpoj1oougPxPAHMfFe9lsTiUAQIQuc39xzPRtgcnkr5hOZs194Ab1XxtEn3luWoJB4uVhVFTNbJTsmw/V+wuXYcph1H8hm2EEAU//lqRC0Db+GqxaENUfG4Yg7AquU/OTEHkivvzaMW6MKmefLyCc9KhHA8GjQRSDfjIkMMerGt2/zQnZ4dywLSUop4jpec+8xzAQJuI2zvArk8Y0BmT792KwwQFIyvDcbDlBVm3IHAoE34Gn2DN1hGeRjIktQTL0HV/AAFaTlP39aQAfuVJEJxwTRBAEGpa+68on04HYFF0AJC1Zj/n3m5KPbVnMJs5mW/9LKQR0RblLuYLrK7uVqLnHqxYw+9yijRF32tWmNpZEKgM6aj0gDaaqEy68tCixW93fyWwFw6CWboApWaaN/hMxvKOLQ7QuVCUj9qC4Mf7JD43t9jnpQFiWEaPM4WKYxLTBRBgKTVlep8vmQBjAoOJebD1IV1OJwzdOHiSL3o0UrqR5i7Ch3/FCuN6fezy4/5aWWEnn2qHGcK0INSbBpmm6rnk5wsCT7mBk4HSdQEI5rMnro0KjvRGwRbLHDDt3yyXzKeZR3KV7a74wTHJWPV1HLPxj41YdNtCj8rLMzndmiqBaqgZwvXbjGrQumlwRi9ZDnTFgpfjaFhePsv591b8G1f1ip+vX0NmA4T6zhiCijI1q2F98IK3kRE3bvhwIUA2E6aktn/TJWMGRX1JSuaatj77TgKavIaNGBnwyjklpteKM445cNzbJQeDClC4wIJH4zpvMrMeZggD19WwC7iax1E8ky5GvCCnYOSH26V5wG2/aOqyXKtthjQy3xtsruhec68RYXDWJlMOa2ssuqImJxrcgJzj7UbwI1K7LzrHSHygHUwgFfDTy7J+K9BgIRCLI9gpUWEBWBGdD0UYNTkqxwzq7JCqyOpft71Ce1m/2QAEoErRaf0P8NjIziyLvEHgj+3nkyX/IBM8OoyIDpAj6mQBOFZ+9m4t0DpxZv9303+AMvQkCKbXORJwwMsPlV1m0vLQjSCLiIFJVxyC2gEmyN87DXEqQNeUzkqQtRItgjNMzUH+6EAYS+ud+A9WOlLY7LQSQe5ifBnvTSMF8PO499ChSZ2qS4k5as3/f0eIZYsshrJeNXx9eIuvnu+Xa6acYNH3EflGukM5AISh0Ms1Fe1cTIp0p+Bap93wLxBry1cjmBgwe+td3C8gEskqerDyULEh7RAzPIAZKll6huwLAeB5haDJoUjLYKkWtiKz8xuSM+VAT+JSsvsf8FyF9BTVjHQIa3cq7qvzqu5oW+8MTtEZrc/XMCN3tQk3u3wLLmtm0IEVUg3NL5DJFKE7pLZaAsGdMqwrx3bHg4RjxpT7ZrFH1fh/6eV1T8oLjcvMz0btqrSya6tXFdEz+bBgDQN9fLOl3uKH1qYzWX+su8rkf2LDAFlxUHrfJ+rdm82GNiUCP/9q+peHYaV8j5Obo4iKDZ4IYksFxgAx70KHYmLcFA7m1W5XGFI7xuqi7L6FERs3HGPV3ym0tgutEj3fz+4UZJVNbjTomq9HBQ8bEfchnw/Fxz1Dzn+QhoBsiE/XFEYSQJjDjeQYISPT4STh38hjkfA/rqkkpHhXj7ZvMZvkJnUAL8BqI9DJQQdOwLq7hjCLfIggHkGdJF1j8DuEFvrkJECaQxZv/fbHY7P21/gLniSVZqhZijU1bV38PqaNbVCgkzY4UmD9r26zcQbldwA4WI1guPSCI/W/Wsf80lNLOkIvvjVh7JC4JeMlh27HaGsLq3rDkx+AQU+MKa9Nz0NFT+E4nlsnQ5sc2Ic2EPKiY+3rz5OEWblV+e2Flu2e8neWesiYwu/p8GmP6gM5mtOVvIRUkUMrfg9uJwLHif4HCvkdTgVoqp236t2ARHzWIc/xLH6XzYG5fN5c3qx9Il3ujtYTgMmSc9nDrKrHmu73Gyqackg9+j3xrs/X/hbXO21K3E1CaKo0Yr67eS3a2P65lrV42Oc6Qb9820hFl7gos+kwh8eRs9qjyUYv2h3XQJsoCCa2lenbjO79kbGkn0lXn/aqnlYT61B1ov3nK49jXvGmD1kJTSShXaq7kA1/G+LNHTiBg2OWokkwCllP25Dv4RKKmSN09kJZZ2s0WZ+UI18IoVlQvYRbm3MNcVj4q7VoKwZI9h/ZNJP7TL46N0cKUBMbgIWP6NPOQYEiz7gNN5LqBxa7wncy+xbzcq14xFA1xa7kjtOBpJF9H4uo1SSs/2sJiSo30RJb6euUb8Mp51TYzMvdjOQ+f943MHBwF4eOW0Mh0kBv92MR/xaK+kgyo3enUvEEvqCcw39PtGF+KBcJMaIRLnV+Yjlxx88SqgT0hJ8FADjGiuJe7xdiqkSyYm21Sr6oGJxNETPMH5ZhswOdH3g2AqyEtYpuz49fPkhEgYbcu7HQnW5pIc1puRsKqKIeZgvTkn+LB/wE9fpIcBgUQtW4ghbwyZbJ/fORoY+fgWycVew59GXF4gngVair4fXsxHJSDBKuhaIPH0dDZvEoyGkMMKtno3Ri6GV1vAjKa5NR0QdwsL5ZgkNinggTiMdvNLpmhEVIiTUCcqBy1e1DviZTwf3w3aKOeXYIQQH9SHGgwAzZWUtFhNyllrVkShH2Xc+OPClNyY3YH6nv4z4PRInB1HAx2NrDWROI9IhGIEoZV6h2Ov2Y7tmbXFu8rTRUk29YFOuq9AF/TqMQvY3F6p0XTUmYkFXA1wbErFw7Vn6d1dnj9uf+jYZZjNu5O3BqCNL4fZBqzmzpo2dJkg2xOxJ3ijfncLgT+qJEbD9rsYMpoWj8IZI0YwNxaE2S2n2JC6PVCqyRVH/HVZGDLyG+tBTwYZmVaQXKWwr2GzWplhM7DRIVCrDAq+0Pg1QsV/cVE9PK9e1V9YW8L4FKbTXr5oF2F5aCxNfTs/syCUw7OjXYe92CYjkvk2FYllEqkx6tXONNw8H7eQQm3YHEU82XckGjYR4D1wtVMqItj+T+hyEvF7bDJYYXWlmWBGqImsbso5ofeGL4NCLqIa75UBPKfHHMlveT2Vp8/KpvzOwnzM9bvuipyvTz1mqFcudJ6Pkp4cyehunWVeDmi19/pJ3+aN2Ubo+dK/88OcblrAVwcd0aTsUAB3vY+dkqOL2N2SFsPGnGCuKa9U4LDS/gyGWpv8ttLjOe9ev+98/twdvCzYAhmpRSr76LgUJe56WbWbD2v1cfmBW//aKbJ95OcpoYIvVGE60k3zzIy2QC00EA9EkgmPG+XSsQeaNfyH3VpMl4AtxAOXgC0V136wouVZQvyrAvj8Fo1kIk2VbvzM+2ItAQ+daohkqw4X85+JavvniTSqBPHOvjjel8YNnooW0qTT68MKXg6XXA9guwD93NffvIccQ2PnJUMiHiH8eja34JSaXk+09YPTeWp8My70bi0o5WJ80SZCL5HFVTNEjCgOEkAxM70WBtGXVeKU5NABjUY2Mq6oFupYbhz45HxC4RENnJCO7fjlfLdieuEZwO5jvd4dWxqAepdFBuFBJ824BOUpIe/vJzTlJayRUBofQSD/SX9U1ks+WXJqjAXvYOcyGGBgAUaEAbrIzfsbs8wmgWLevDPzsrnd071I1GfTLBpvUITTO40eyv5E0/ZISVy7QUS3+rzLmdDIs9o1IytHwOrtFmsZkGoRUhiQdbx9DQnG1/VHeMtobw/RNL5odIon2O5wSUiEoQDwgxAbGOJM4cnArV5JamgaJMhpEe1+H7A+/ZW/fY4JZJLl0LrsdMmzaC/tVzw2/6EFJqfZymMscByCa4NdOszEKgFAIY+dyQKkFgPe8tEgkBA8j2VceCXDkJxbANH197N3TZRDsnRYLHNmE8gG5K7IVpkpYAv8/vaQ94qpFJQREhR2DK0QFxU6cHFS+g==</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    <summary type="html">
    
      早知道是这样 像梦一场 我才不会把爱都放在同一个地方
    
    </summary>
    
      <category term="往事回廊" scheme="http://quiryrain.tk/categories/%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BB%8A/"/>
    
    
      <category term="一场梦" scheme="http://quiryrain.tk/tags/%E4%B8%80%E5%9C%BA%E6%A2%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用tkinter进行图片的遍历显示</title>
    <link href="http://quiryrain.tk/190228/"/>
    <id>http://quiryrain.tk/190228/</id>
    <published>2019-02-28T10:06:46.000Z</published>
    <updated>2019-03-05T13:32:48.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>最近因为要写个GUI的内容，需要用到图像的遍历显示，因为没有办法,所以就自行摸索着开始写一个循环显示的TK。最终算是不符所望吧，勉强写出来一个，以此做下记录，便于下次使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageTk, Image</span><br><span class="line"><span class="keyword">import</span> glob, time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">filenames = glob.glob(<span class="string">'sysImages/*'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoQuit</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    root.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line"></span><br><span class="line">    img = Image.open(filename)</span><br><span class="line">    photo = ImageTk.PhotoImage(img)</span><br><span class="line">    label = tk.Label(image=photo)</span><br><span class="line">    label.image = photo</span><br><span class="line">    label.pack()</span><br><span class="line"></span><br><span class="line">    t = threading.Thread(target=autoQuit)</span><br><span class="line">    t.start()</span><br><span class="line">    root.mainloop()</span><br><span class="line">    root.destroy()</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;最近因为要写个GUI的内容，需要用到图像的遍历显示，因为没有办法,所以就自行摸索着开始写一个循环显示的TK。最终算是不符所望吧，勉强写出来一
      
    
    </summary>
    
      <category term="Python杂记" scheme="http://quiryrain.tk/categories/Python%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="tkinter" scheme="http://quiryrain.tk/tags/tkinter/"/>
    
      <category term="遍历图片" scheme="http://quiryrain.tk/tags/%E9%81%8D%E5%8E%86%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>使用Python实现贪心算法</title>
    <link href="http://quiryrain.tk/180113/"/>
    <id>http://quiryrain.tk/180113/</id>
    <published>2019-02-26T03:14:50.000Z</published>
    <updated>2019-06-21T03:33:07.247Z</updated>
    
    <content type="html"><![CDATA[<p>题目： 圣诞节来临了，在城市A中，圣诞老人准备分发糖果。现在有多箱不同的糖果，每一种糖果都有自己的价值和重量。每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果。请问圣诞老人最多能带走多大价值的糖果。</p><p>输入数据： 输入的第一行由两个部分组成，分别为糖果箱数正整数n(1&lt;=n&lt;=100)，驯鹿能承受的最大重量正整数w(0&lt;w&lt;10000)；其余n行每行对应一箱糖果，由两部分正整数v和w组成，分别为一箱糖果的价值和重量。</p><p>输出要求： 输出圣诞老人能带走的糖果的最大总价值，保留一位小数，输出为一行。</p><p>输出样例： </p><table><thead><tr><th style="text-align:left">需要装的箱数</th><th style="text-align:left">4</th></tr></thead><tbody><tr><td style="text-align:left">驯鹿最大承受重量</td><td style="text-align:left">15</td></tr></tbody></table><table><thead><tr><th style="text-align:left">批次</th><th style="text-align:left">价值</th><th style="text-align:left">重量</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">4</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">100</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">412</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">266</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">591</td><td style="text-align:left">2</td></tr></tbody></table><p>输出样例:</p><p>　1193.0</p><p>注：此处并没有按照这样的格式进行输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line">input_a = raw_input(<span class="string">u'箱数:'</span>)</span><br><span class="line">input_b = raw_input(<span class="string">u'最大承受重量:'</span>)</span><br><span class="line"></span><br><span class="line">list_c = []</span><br><span class="line">list_z = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(input_a)+<span class="number">1</span>):</span><br><span class="line">    input_c = raw_input(<span class="string">'第'</span>+str(i)+<span class="string">'箱的总价值:'</span>)</span><br><span class="line">    input_d = raw_input(<span class="string">'第'</span>+str(i)+<span class="string">'箱的重量:'</span>)</span><br><span class="line">    avg = round(int(input_c)/int(input_d),<span class="number">1</span>)<span class="comment">#每一箱，重量为1的价值</span></span><br><span class="line">    list_c.append(avg)<span class="comment">#添加到列表，用于之后做比较</span></span><br><span class="line">    list_z.append([int(input_d),avg,<span class="number">0</span>])<span class="comment">#此处列表中添加列表，中间的列表一个存放总重量，第二个存放单位价值，第三个存放是否该物品已被取走</span></span><br><span class="line"></span><br><span class="line">list_c.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序排序</span></span><br><span class="line">sum =[<span class="number">0</span>,<span class="number">0</span>]<span class="comment"># 用于存放取走的总重量，第一个参数是取走的重量，第二个是超出前的备份</span></span><br><span class="line">num =<span class="number">0</span></span><br><span class="line">ji = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_c)):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(list_z)):</span><br><span class="line">        <span class="keyword">if</span> ji == <span class="number">0</span>:<span class="comment">#做是否超出马车最大承受量的标记，未超出为0</span></span><br><span class="line">            <span class="keyword">if</span> (list_c[i] == list_z[k][<span class="number">1</span>]) <span class="keyword">and</span> (list_z[k][<span class="number">2</span>]==<span class="number">0</span>):</span><br><span class="line">                sum[<span class="number">1</span>] = sum[<span class="number">0</span>]<span class="comment">#备份</span></span><br><span class="line">                sum[<span class="number">0</span>] = sum[<span class="number">0</span>] + list_z[k][<span class="number">0</span>]<span class="comment">#取走的重量</span></span><br><span class="line">                v = list_z[k][<span class="number">0</span>]<span class="comment">#取走的重量</span></span><br><span class="line">                <span class="keyword">if</span> sum[<span class="number">0</span>] &gt; int(input_b):<span class="comment">#如果所有取走的重量超出马车的重量，就依次减少一单元的重量</span></span><br><span class="line">                    ji = <span class="number">1</span><span class="comment">#超出为1</span></span><br><span class="line">                    t= list_z[k][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#依次减去单位1的重量</span></span><br><span class="line">                        z = sum[<span class="number">1</span>] + t<span class="comment">#使用备份进行判断，此时取走的数量已经大于最大承受量了</span></span><br><span class="line">                        <span class="keyword">if</span> z &lt;= int(input_b):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        t = t<span class="number">-1</span></span><br><span class="line">                    v=t<span class="comment">#等于最大承受量时，价值较大的一件物品应取走的数量</span></span><br><span class="line">                    sum[<span class="number">0</span>]=sum[<span class="number">1</span>]<span class="comment">#从备份恢复</span></span><br><span class="line">                    sum[<span class="number">0</span>] = sum[<span class="number">0</span>] + t<span class="comment">#此时为真正的取走数量</span></span><br><span class="line">                num = list_c[i]*v + num<span class="comment">#总价值</span></span><br><span class="line">                list_z[k][<span class="number">2</span>] = <span class="number">1</span><span class="comment">#取走的标记</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">u'能带走的糖果的最大价值为:'</span>,num</span><br></pre></td></tr></table></figure><p>实现的效果图(此处用两组数据进行测试)：<br>第一组数据：<br><img src="/userImages/tanxin1.png" alt="测试结果1"></p><p>第二组数据：<br><img src="/userImages/tanxin2.png" alt="测试结果2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目： 圣诞节来临了，在城市A中，圣诞老人准备分发糖果。现在有多箱不同的糖果，每一种糖果都有自己的价值和重量。每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果。请问圣诞老人最多能带走多大价值的糖果。&lt;/p&gt;
&lt;p&gt;输入数据： 输入的第一行由两个
      
    
    </summary>
    
      <category term="Python杂记" scheme="http://quiryrain.tk/categories/Python%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="贪心算法" scheme="http://quiryrain.tk/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Python实现的杨辉三角</title>
    <link href="http://quiryrain.tk/171222/"/>
    <id>http://quiryrain.tk/171222/</id>
    <published>2019-02-26T03:10:30.000Z</published>
    <updated>2019-03-05T13:32:48.672Z</updated>
    
    <content type="html"><![CDATA[<p>某日，闲来无事做，就尝试着用Python实现了下杨辉三角，以下使用Python2 实现的杨辉三角 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangel</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">' '</span>*(<span class="number">20</span>*<span class="number">3</span>)+str(<span class="number">1</span>)             <span class="comment">#定义起始两行</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">' '</span>*(<span class="number">19</span>*<span class="number">3</span>)+str(<span class="number">1</span>)+<span class="string">' '</span>*<span class="number">5</span>+str(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">21</span>):</span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">3</span>:</span><br><span class="line">            L = [<span class="number">1</span>,<span class="number">1</span>]       <span class="comment">#初始化第二行        </span></span><br><span class="line">        L1 = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,i):</span><br><span class="line">            z = L[i-j<span class="number">-1</span>]+L[i-j] <span class="comment"># 通过上一行构建下一层数据</span></span><br><span class="line">            L1.append(z)        <span class="comment"># 将数据添加到一个空列表中</span></span><br><span class="line">        L = [<span class="number">1</span>]       <span class="comment"># 再次对L初始化</span></span><br><span class="line">        L.extend(L1)    <span class="comment"># 将两个列表合并</span></span><br><span class="line">        L.append(<span class="number">1</span>)     <span class="comment"># 在L列表中添加最后一个数据“1”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下内容为杨辉三角的打印</span></span><br><span class="line">        t = <span class="string">' '</span>*((<span class="number">21</span>-i)*<span class="number">3</span>)+str(<span class="number">1</span>)   <span class="comment"># 每次循环进行初始化每列的第一个数据1</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">1</span>,len(L)):   <span class="comment"># 以下为构建每列的除一个数据外的其他数据，</span></span><br><span class="line">            <span class="keyword">if</span> L[h]&lt;<span class="number">10</span>:             <span class="comment"># 如果数据小于10，就是其前面5个空格，如果</span></span><br><span class="line">                t = t + <span class="string">' '</span>*<span class="number">5</span>+str(L[h]) <span class="comment">#数据小于100，就减少一个空格，依次类推，</span></span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt;<span class="number">100</span>:         <span class="comment"># 直至剩余一个空格，用于分辨相邻的数据</span></span><br><span class="line">                t = t+<span class="string">' '</span>*<span class="number">4</span>+str(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">1000</span>:</span><br><span class="line">                t = t + <span class="string">' '</span>*<span class="number">3</span>+str(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">10000</span>:</span><br><span class="line">                t = t + <span class="string">' '</span>*<span class="number">2</span>+str(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">100000</span>:</span><br><span class="line">                t = t + <span class="string">' '</span>*<span class="number">1</span>+str(L[h])</span><br><span class="line">        <span class="keyword">print</span> t</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    triangel()</span><br></pre></td></tr></table></figure><p><img src="/userImages/yanghuisanjiao.png" alt="杨辉三角"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某日，闲来无事做，就尝试着用Python实现了下杨辉三角，以下使用Python2 实现的杨辉三角 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="Python杂记" scheme="http://quiryrain.tk/categories/Python%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杨辉三角" scheme="http://quiryrain.tk/tags/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>使用chromedriver实现豆瓣网页的全网页截图</title>
    <link href="http://quiryrain.tk/190108/"/>
    <id>http://quiryrain.tk/190108/</id>
    <published>2019-02-26T02:48:23.000Z</published>
    <updated>2019-03-05T13:32:48.676Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于工作需要，需要对部分网站进行全文截屏。在网上搜了很久没有搜出好的方法，而且在新版的selenium中已经不在支持PhantomJS了，所以全文截取变得有点棘手。</p><p>此处给出一个简单的方法，以20行代码实现<code>selenium+chromedriver+python</code>实现豆瓣的全文截取。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--dns-prefetch-disable'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--no-referrers'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--disable-gpu'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--disable-audio'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--no-sandbox'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--ignore-certificate-errors'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--allow-insecure-localhost'</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line">driver.get(<span class="string">'http://www.douban.com'</span>)</span><br><span class="line">width = driver.execute_script(</span><br><span class="line">        <span class="string">"return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);"</span>)</span><br><span class="line">height = driver.execute_script(</span><br><span class="line">        <span class="string">"return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);"</span>)</span><br><span class="line">driver.set_window_size(width + <span class="number">100</span>, height + <span class="number">100</span>)</span><br><span class="line">driver.save_screenshot(<span class="string">'douban.png'</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p><img src="/userImages/doubanjieping.png" alt="豆瓣全屏截取"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近由于工作需要，需要对部分网站进行全文截屏。在网上搜了很久没有搜出好的方法，而且在新版的selenium中已经不在支持PhantomJS了，所以全文截取变得有点棘手。&lt;/p&gt;
&lt;p&gt;此处给出一个简单的方法，以20行代码实现&lt;code&gt;selenium+chromedriv
      
    
    </summary>
    
      <category term="Python后端" scheme="http://quiryrain.tk/categories/Python%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Chromedriver" scheme="http://quiryrain.tk/tags/Chromedriver/"/>
    
      <category term="全页面截屏" scheme="http://quiryrain.tk/tags/%E5%85%A8%E9%A1%B5%E9%9D%A2%E6%88%AA%E5%B1%8F/"/>
    
  </entry>
  
</feed>
